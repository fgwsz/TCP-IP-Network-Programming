# 第一章 理解网络编程和套接字
## 1.1 理解网络编程和套接字
控制台输入输出和文件输入输出非常类似.

实际上，网络编程也与文件输入输出有很多相似之处.
### 网络编程和套接字概要
`网络编程`是编写程序使两台联网的计算机相互交换数据.

这两台计算机之间传输数据的必要条件:
1. 物理连接(连接到互联网)
2. 编写数据传输软件(操作系统提供了名为`套接字`(`socket`)的部件)

套接字是网络编程数据传输用的软件设备.

网络编程又称为套接字编程.

如何理解`套接字`一词?

`套接字`(`socket`)一词更加契合实际生活的中文翻译是`插座`.

把插头插到插座上就能从电网获得电力供应,同样地,
为了与远程计算机进行数据传输,也需要连接互联网,
而编程中的`套接字`就是用来连接网络的`插座`.
### 构建接电话套接字
套接字大致分为2种,这里介绍的是`TCP`套接字.

通过如下的过程来模仿`TCP`套接字接收请求的过程,方便理解和记忆.

#### 调用`socket`函数(安装电话机)时进行的对话
创建一个套接字等价于安装一台电话机.
##### `socket()`创建套接字
```c
#include<sys/socket.h>
int socket(int domain,int type,int protocol);
    //成功时返回文件描述符
    //失败时返回-1
```
#### 调用`bind`函数(分配电话号码)时进行的对话
调用`bind`函数给创建好的套接字分配地址信息(`IP`地址和端口号),
这个过程就想给电话机分配电话号码一样.
##### `bind()`分配`IP`地址和端口号
```c
#include<sys/socket.h>
int bind(int sockfd,struct sockaddr* myaddr,socklen_t addrlen);
    //成功时返回0
    //失败时返回-1
```
调用`bind()`成功后,就基本完成了接电话的所有准备工作.

接下来需要连接电话线并等待来电.
#### 调用`listen`函数(连接电话线)时进行的对话
一连接电话线,电话机就转为可接听状态,这时其他人可以拨打电话连接请求到该机.

与之类似,可以调用`listen()`函数,将套接字设置为可接收连接的状态.
##### `listen()`将套接字设置为可接收连接的状态
```c
#include<sys/socket.h>
int listen(int sockfd,int backlog);
    //成功时返回0
    //失败时返回-1
```
疑惑:

这里的输入参数`backlog`指的是什么?

是可以接收连接请求的最大连接数量吗?
#### 调用`accept`函数(拿起话筒)时进行的对话
连接好电话线(`listen()`),如果有人拨打电话就会响铃,拿起话筒才能接听.

拿起话筒,意味着接收了对方的连接请求.

套接字使用`accept`函数模仿这一过程.
##### `accept()`接收连接请求(得到连接请求方的套接字信息)
```c
#include<sys/socket.h>
int accept(int sockfd,struct sockaddr* addr,socklen_t* addrlen);
    //成功时返回文件描述符
    //失败时返回-1
```
疑惑:
1. `accept()`的参数列表是连接请求方的`IP`地址和端口号信息吗?
2. `accept()`调用之后,能否通过`解引用`传入参数`addr`和`addrlen`,得到连接请求方的`IP`地址和端口号信息?
2. `accept()`的返回值是连接请求方的套接字文件描述符号吗?
#### 网络编程中接收连接请求的过程
1. 调用`socket()`创建套接字
2. 调用`bind()`分配`IP`地址和端口号
3. 调用`listen()`转为可接收请求状态
4. 调用`accept()`受理连接请求
### 编写`Hello world!`服务器端
服务器端（`server`）是能够受理连接请求的程序.

该服务器端的业务逻辑:收到连接请求后向请求者返回`Hello world!`答复.
#### `hello_server.c`
```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<unistd.h>
#include<arpa/inet.h>
#include<sys/socket.h>

void error_handling(char const* message);

int main(int argc,char* argv[]){

    if(argc!=2){
        printf("Usage:%s <port>\n",argv[0]);
        exit(1);
    }

    int serv_sock;

    //调用socket()创建套接字
    serv_sock=socket(PF_INET,SOCK_STREAM,0);
    if(serv_sock==-1){
        error_handling("socket() error!");
    }

    struct sockaddr_in serv_addr;
    memset(&serv_addr,0,sizeof(serv_addr));
    serv_addr.sin_family=AF_INET;
    serv_addr.sin_addr.s_addr=htonl(INADDR_ANY);
    serv_addr.sin_port=htons(atoi(argv[1]));

    //调用bind()分配IP地址和端口号
    if(bind(serv_sock,(struct sockaddr*)&serv_addr,sizeof(serv_addr))==-1){
        error_handling("bind() error!");
    }

    //调用listen()将套接字转为可接收连接状态
    if(listen(serv_sock,5)==-1){
        error_handling("listen() error!");
    }

    int clnt_sock;
    struct sockaddr_in clnt_addr;
    socklen_t clnt_addr_size;
    clnt_addr_size=sizeof(clnt_addr);

    //调用accpet()受理连接请求
    //如果在没有连接请求的情况下调用该函数,则不会返回,
    //直到有连接请求为止才返回(阻塞等待吗?)
    clnt_sock=accept(serv_sock,(struct sockaddr*)&clnt_addr,&clnt_addr_size);
    if(clnt_sock==-1){
        error_handling("accept() error!");
    }

    char message[]="Hello World!";

    //write()用于传输数据
    write(clnt_sock,message,sizeof(message));

    close(clnt_sock);
    close(serv_sock);
    return 0;
}
void error_handling(char const* message){
    fputs(message,stderr);
    fputc('\n',stderr);
    exit(1);
}
```
### 构建打电话套接字
服务器端创建的套接字称为`服务器端套接字`或`监听(listening)套接字`.

接下来介绍的套接字是用于连接请求的`客户端套接字`.

这里总结一下:
1. 主动监听`->`服务端套接字
2. 主动连接请求`->`客户端套接字

主动给其他人打电话(发起连接请求)的函数还未介绍,
这就是客户端套接字调用的`connect`函数.

#### `connect()`发起连接请求
```c
#include<sys/socket.h>
int connect(int sockfd,struct sockaddr* serv_addr,socklen_t addrlen);
    //成功时返回0
    //失败时返回-1
```
#### 客户端发起连接请求的过程
客户端使用套接字发起连接请求的过程,比服务端监听接收请求的过程,步骤更简单.

客户端发起连接请求的过程:
1. 调用`socket()`创建套接字
2. 调用`connect()`向服务器端发送连接请求

下面给出客户端,该客户端的业务逻辑:
1. 调用`socket()`和`connect()`
2. 与服务器端共同运行以收发字符串数据
#### `hello_client.c`
```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<unistd.h>
#include<arpa/inet.h>
#include<sys/socket.h>

void error_handling(char const* message);

int main(int argc,char* argv[]){

    if(argc!=3){
        printf("Usage:%s <IP> <port>\n",argv[0]);
        exit(1);
    }

    int sock;

    //调用socket()创建套接字
    //判断套接字是服务器端套接字还是客户端套接字的方法
    //如果套接字创建之后紧接着调用bind() & listen(),就是服务器端套接字
    //如果套接字创建之后调用connect(),就是客户端套接字
    sock=socket(PF_INET,SOCK_STREAM,0);
    if(sock==-1){
        error_handling("socket() error!");
    }

    struct sockaddr_in serv_addr;
    memset(&serv_addr,0,sizeof(serv_addr));
    serv_addr.sin_family=AF_INET;
    serv_addr.sin_addr.s_addr=inet_addr(argv[1]);
    serv_addr.sin_port=htons(atoi(argv[2]));

    //调用connect()向服务器端发起连接请求
    if(connect(sock,(struct sockaddr*)&serv_addr,sizeof(serv_addr))==-1){
        error_handling("connect() error!");
    }

    int str_len;
    char message[30];
    str_len=read(sock,message,sizeof(message)-1);
    if(str_len==-1){
        error_handling("read() error!");
    }
    printf("Message from server : %s \n",message);

    close(sock);
    return 0;
}
void error_handling(char const* message){
    fputs(message,stderr);
    fputc('\n',stderr);
    exit(1);
}
```
### 在`Linux`平台下运行
`hello_server.c`和`hello_client.c`都应在`Linux`环境中编译执行.

`C`语言编译器`GCC`编译器对`hello_server.c`进行编译:
```bash
#编译hello_server.c文件并生成可执行文件hserver
gcc hello_server.c -o hserver
```
`gcc`命令中的`-o`是也能够来指定可执行文件名的可选参数.

因此,编译后将在当前路径下生成名为`hserver`的可执行文件

执行如下的命令运行可执行程序:
```bash
#运行当前目录下的hserver文件
./hserver
```
服务器端需要在运行时接收客户端的连接请求,因此,服务器端需要先运行.
```bash
#运行服务器端
gcc hello_server.c -o hserver
./hserver 9190
```
正常情况下,服务器端会因为调用`accept()`,在处于未监听到连接请求时陷入等待状态.

等到有连接请求,`accept()`才会返回.
```bash
#运行客户端
gcc hello_client.c -o hclient
./hclient 127.0.0.1 9190
```
客户端的运行结果:
```bash
Message from server : Hello World! 
```
`127.0.0.1`是运行示例用的计算机(本机计算机)的`IP`地址
(常用于指代实际的本机`IP`地址).

如果在同一台计算机运行服务器端和客户端,将采用这种连接方式.

但如果服务器端与客户端在不同的计算机中运行,
则应采用服务器端所在计算机的`IP`地址.

#### `hello_server`无法立即重新运行的`Bug`
当服务器端和客户端运行结束之后,立即重新运行服务器端程序,
会发现服务器端提示如下错误:
```bash
bind() error!
```
等待一段时间后,再次重新运行服务器端程序,发现错误消失了.

这是怎么一回事呢?

这里给出一个可能的解决办法:

上面的服务器端无法立即重新运行,
如果希望立即重新运行,需要更改端口号为`9190`之外的其他端口号.

现在不必对此感到意外,原因后面会讲.
## 1.2 基于`Linux`的文件操作
在`Linux`操作系统中,`socket`被认为是文件的一种.

因此在网络数据传输中可以使用文件`I/O`相关函数来操作`socket`.

`Windows`与`Linux`不同,是区分`socket`和文件的.

因此在`Windows`中需要调用特殊的数据传输相关函数来操作`socket`.
### 底层文件访问(`Low-Level File Access`)和文件描述符(`File Descriptor`)
`Linux`提供了一系列与`C`语言标准无关的文件`I/O`函数.

`文件描述符`的概念

`文件描述符`是系统分配给文件或套接字的整数.

`C`语言的标准输入输出及标准错误在`Linux`中也被分配了指定的文件描述符.

#### 表1-1 分配给标准输入输出及标准错误的文件描述符
文件描述符|对象
:--------:|:---
0|标准输入:Standard Input
1|标准输出:Standard Output
2|标准错误:Standard Error

文件和套接字一般经过创建过程才会被分配文件描述符.

上表中的3种输入输出对象即便是未经过特殊的文件创建过程,
在程序开始运行后也会被自动分配文件描述符.

#### 文件描述符(文件句柄)
文件描述符指的是`Linux`操作系统给文件或者套接字为了方便称呼/操作所赋予的编号.

每当调用系统接口,创建文件或套接字,操作系统将返回分配给他们的整数编号.

文件描述符在`Windows`中称为`文件句柄`.

`句柄`是`Windows`中的术语,如果是`Linux`平台则用`描述符`(`Descriptor`)一词.
### 打开文件
首先介绍打开文件以读写数据的函数`open()`.
#### `open()`
```c
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>

//path:文件名的字符串地址
//flag:文件打开模式信息
int open(char const* path,int flag);
    //成功时返回文件描述符
    //失败时返回-1
```
#### 表1-2 `open()` `flag`可能的常量值及含义
打开模式  |含义
:--------:|:---
`O_CREAT` |必要时创建文件
`O_TRUNC` |删除全部现有数据
`O_APPEND`|维持现有数据,保存到其后面
`O_RDONLY`|只读打开
`O_WRONLY`|只写打开
`O_RDWR`  |读写打开

如需向`open()`传递多种文件打开模式信息,
则应该通过位或运算`operator |`组合并传递.

例如:`open("output.txt",O_CREAT|O_TRUNC|O_RDWR)`

### 关闭文件
使用文件后必须关闭文件.下面介绍关闭文件时调用的函数`close()`.
#### `close()`
```c
#include<unistd.h>

//fd:需要关闭的文件或套接字的文件描述符
int close(int fd);
    //成功时返回0
    //失败时返回-1
```
因为在`Linux`中不区分文件和套接字,因此`close()`可以用来关闭套接字.
### 将数据写入文件
接下来介绍用于向文件/套接字输出(传输)数据的函数`write()`.
#### `write()`
```c
#include<unistd.h>

//fd:显示数据传输对象的文件描述符
//buf:保存要传输数据的缓冲地址值
//nbytes:要传输数据的字节数
ssize_t write(int fd,void const* buf,size_t nbytes);
    //成功时返回写入的字节数
    //失败时返回-1
```
在此函数定义中,
`size_t`是`typedef unsigned int size_t;`
而`ssize_t`是`typedef signed int ssize_t;`
##### 以`_t`为后缀的数据类型
`Linux`操作系统在`sys/types.h`声明定义了一系列`_t`的元数据类型(`primitive`).

但是既然`C`语言已经有了基本数据类型,为什么还要声明这些新的`_t`数据类型呢?

在过去的16位操作系统时代,`int`类型是16位的.

但是随着时代的变化,`int`类型等基本类型可能是32位/64位.

如果在使用整数/正整数类型的地方使用了`ssize_t`/`size_t`,
那么在数据类型进行变更的时候,
只需要重新修改`ssize_t`/`size_t`的`typedef`定义即可,
大大减少了代码的变动.
### 写入文件示例
下面的程序将创建新文件并保存数据.
#### `low_open.c`
```c
#include<stdio.h>
#include<stdlib.h>
#include<fcntl.h>
#include<unistd.h>

void error_handling(char const* message);

int main(void){

    int fd;

    //文件打开模式位O_CREAT|O_WRONLY|O_TRUNC的组合
    //创建空文件,并只能写
    //若存在data.txt文件,则清空文件的全部数据
    fd=open("data.txt",O_CREAT|O_WRONLY|O_TRUNC);
    if(fd==-1){
        error_handling("open() error!");
    }

    printf("file descriptor: %d \n",fd);
    char buf[]="Let's go!\n";

    //向对应于fd中保存的文件描述符的文件传输buf中保存的数据
    if(write(fd,buf,sizeof(buf))==-1){
        error_handling("write() error!");
    }

    close(fd);
    return 0;
}
void error_handling(char const* message){
    fputs(message,stderr);
    fputc('\n',stderr);
    exit(1);
}
```
运行结果:
```txt
file descriptor: 3 
```
`data.txt`中的内容:
```txt
Let's go!
```
### 读取文件中的数据
下面介绍用于输入(接收)数据的函数`read()`.
#### `read()`
```c
#include<unistd.h>

//fd:显示数据接收对象的文件描述符
//buf:要保存接收数据的缓冲地址值
//nbytes:要接收数据的最大字节数
ssize_t read(int fd,void* buf,size_t nbytes);
    //成功时返回就收的字节数(但遇到文件结尾则返回0)
    //失败时返回-1
```
### 读取文件示例
下面示例通过`read()`读取`data.txt`中保存的数据.
#### `low_read.c`
```c
#include<stdio.h>
#include<stdlib.h>
#include<fcntl.h>
#include<unistd.h>

#define BUF_SIZE 100

void error_handling(char const* message);

int main(void){

    int fd;

    //打开读取专用文件data.txt
    fd=open("data.txt",O_RDONLY);
    if(fd==-1){
        error_handling("open() error!");
    }

    printf("file descriptor: %d \n",fd);
    char buf[BUF_SIZE];

    //调用read()向数组buf保存读入的数据
    if(read(fd,buf,sizeof(buf))==-1){
        error_handling("read() error!");
    }

    printf("file data: %s",buf);

    close(fd);
    return 0;
}
void error_handling(char const* message){
    fputs(message,stderr);
    fputc('\n',stderr);
    exit(1);
}
```
运行结果:
```txt
file descriptor: 3 
file data: Let's go!
```
### 文件描述符与套接字
下面将同时创建文件和套接字,并用整数形态比较返回的文件描述符的值.
#### `fd_seri.c`
```c
#include<stdio.h>
#include<fcntl.h>
#include<unistd.h>
#include<sys/socket.h>

int main(void){

    int fd1,fd2,fd3;

    fd1=socket(PF_INET,SOCK_STREAM,0);
    fd2=open("test.dat",O_CREAT|O_WRONLY|O_TRUNC);
    fd3=socket(PF_INET,SOCK_DGRAM,0);

    printf("file descriptor 1: %d\n",fd1);
    printf("file descriptor 2: %d\n",fd2);
    printf("file descriptor 3: %d\n",fd3);

    close(fd1);
    close(fd2);
    close(fd3);
    return 0;
}
```
运行结果:
```txt
file descriptor 1: 3
file descriptor 2: 4
file descriptor 3: 6
```
从输出的文件描述符的整数值可以看出,描述符从3开始由小到大进行编号,
且与文件的创建的先后顺序有关.

至于为什么从3开始,是因为0/1/2是操作系统分配给标准输入输出以及标准错误的描述符.
(表1-1中已讲过)
## 1.5 习题
(1) 套接字在网络编程中的作用是什么?为何称它为套接字?

(2) 在服务器端创建套接字后,会依次调用`listen()`和`accept()`,
请比较并说明二者作用.

(3) `Linux`中,对套接字数据进行`I/O`时可以直接使用文件`I/O`相关函数;
而在`Windows`中则不可以,原因为何?

(4) 创建套接字后一般会给它分配地址,为什么?为了完成地址分配需要调用那个函数?

(5) `Linux`中的文件描述符与`Windows`的句柄实际上非常类似.
请以套接字为对象说明它们的含义.

(6) 底层文件`I/O`函数与`ANSI`标准定义的文件`I/O`函数之间有何区别?

(7) 参考本书给出的示例`low_open.c`和`low_read.c`,
分别利用底层文件`I/O`和`ANSI`标准`I/O`编写文件复制程序.
可任意指定复制程序的使用方法.
### 解答
(1) 套接字在网路编程中起到连接两个设备进行数据通信的作用.
套接字的另一种翻译是插座,本身就有连接的意思.

(2) `listen()`用于将一个套接字设置为可接收连接请求的状态,
`accept()`作用于可接收连接请求的套接字上,处理一个具体的连接请求.

(3) 在`Linux`中套接字属于文件的一种,因此可以直接通过文件`I/O`函数来操作套接字.
而在`Windows`中情况完全不同,文件和套接字是两种不同的类型,
无法使用文件`I/O`函数来操作套接字.

(4) 套接字分配地址是因为在通信中需要明确连接到哪个设备.

套接字不一定都会分配地址,`TCP`客户端创建套接字后,并不需要分配地址,
而是直接使用`connect()`得到服务器端的地址,
,而服务器端套接字要分配地址是通过调用`bind()`函数.

(5)

(6)

(7) 见`ch01-low_open_stdc`和`ch01-low_read_stdc`文件夹.
