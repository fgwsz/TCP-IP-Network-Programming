# 第一章 理解网络编程和套接字
## 1.1 理解网络编程和套接字
控制台输入输出和文件输入输出非常类似.

实际上，网络编程也与文件输入输出有很多相似之处.
### 网络编程和套接字概要
`网络编程`是编写程序使两台联网的计算机相互交换数据.

这两台计算机之间传输数据的必要条件:
1. 物理连接(连接到互联网)
2. 编写数据传输软件(操作系统提供了名为`套接字`(`socket`)的部件)

套接字是网络编程数据传输用的软件设备.

网络编程又称为套接字编程.

如何理解`套接字`一词?

`套接字`(`socket`)一词更加契合实际生活的中文翻译是`插座`.

把插头插到插座上就能从电网获得电力供应,同样地,
为了与远程计算机进行数据传输,也需要连接互联网,
而编程中的`套接字`就是用来连接网络的`插座`.
### 构建接电话套接字
套接字大致分为2种,这里介绍的是`TCP`套接字.

通过如下的过程来模仿`TCP`套接字接收请求的过程,方便理解和记忆.

#### 调用`socket`函数(安装电话机)时进行的对话
创建一个套接字等价于安装一台电话机.
##### `socket()`创建套接字
```c
#include<sys/socket.h>
int socket(int domain,int type,int protocol);
    //成功时返回文件描述符
    //失败时返回-1
```
#### 调用`bind`函数(分配电话号码)时进行的对话
调用`bind`函数给创建好的套接字分配地址信息(`IP`地址和端口号),
这个过程就想给电话机分配电话号码一样.
##### `bind()`分配`IP`地址和端口号
```c
#include<sys/socket.h>
int bind(int sockfd,struct sockaddr* myaddr,socklen_t addrlen);
    //成功时返回0
    //失败时返回-1
```
调用`bind()`成功后,就基本完成了接电话的所有准备工作.

接下来需要连接电话线并等待来电.
#### 调用`listen`函数(连接电话线)时进行的对话
一连接电话线,电话机就转为可接听状态,这时其他人可以拨打电话连接请求到该机.

与之类似,可以调用`listen()`函数,将套接字设置为可接收连接的状态.
##### `listen()`将套接字设置为可接收连接的状态
```c
#include<sys/socket.h>
int listen(int sockfd,int backlog);
    //成功时返回0
    //失败时返回-1
```
疑惑:

这里的输入参数`backlog`指的是什么?

是可以接收连接请求的最大连接数量吗?
#### 调用`accept`函数(拿起话筒)时进行的对话
连接好电话线(`listen()`),如果有人拨打电话就会响铃,拿起话筒才能接听.

拿起话筒,意味着接收了对方的连接请求.

套接字使用`accept`函数模仿这一过程.
##### `accept()`接收连接请求(得到连接请求方的套接字信息)
```c
#include<sys/socket.h>
int accept(int sockfd,struct sockaddr* addr,socklen_t* addrlen);
    //成功时返回文件描述符
    //失败时返回-1
```
疑惑:
1. `accept()`的参数列表是连接请求方的`IP`地址和端口号信息吗?
2. `accept()`调用之后,能否通过`解引用`传入参数`addr`和`addrlen`,得到连接请求方的`IP`地址和端口号信息?
2. `accept()`的返回值是连接请求方的套接字文件描述符号吗?
#### 网络编程中接收连接请求的过程
1. 调用`socket()`创建套接字
2. 调用`bind()`分配`IP`地址和端口号
3. 调用`listen()`转为可接收请求状态
4. 调用`accept()`受理连接请求
### 编写`Hello world!`服务器端
服务器端（`server`）是能够受理连接请求的程序.

该服务器端的业务逻辑:收到连接请求后向请求者返回`Hello world!`答复.
#### `hello_server.c`
```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<unistd.h>
#include<arpa/inet.h>
#include<sys/socket.h>

void error_handling(char const* message);

int main(int argc,char* argv[]){

    if(argc!=2){
        printf("Usage:%s <port>\n",argv[0]);
        exit(1);
    }

    int serv_sock;

    //调用socket()创建套接字
    serv_sock=socket(PF_INET,SOCK_STREAM,0);
    if(serv_sock==-1){
        error_handling("socket() error!");
    }

    struct sockaddr_in serv_addr;
    memset(&serv_addr,0,sizeof(serv_addr));
    serv_addr.sin_family=AF_INET;
    serv_addr.sin_addr.s_addr=htonl(INADDR_ANY);
    serv_addr.sin_port=htons(atoi(argv[1]));

    //调用bind()分配IP地址和端口号
    if(bind(serv_sock,(struct sockaddr*)&serv_addr,sizeof(serv_addr))==-1){
        error_handling("bind() error!");
    }

    //调用listen()将套接字转为可接收连接状态
    if(listen(serv_sock,5)==-1){
        error_handling("listen() error!");
    }

    int clnt_sock;
    struct sockaddr_in clnt_addr;
    socklen_t clnt_addr_size;
    clnt_addr_size=sizeof(clnt_addr);

    //调用accpet()受理连接请求
    //如果在没有连接请求的情况下调用该函数,则不会返回,
    //直到有连接请求为止才返回(阻塞等待吗?)
    clnt_sock=accept(serv_sock,(struct sockaddr*)&clnt_addr,&clnt_addr_size);
    if(clnt_sock==-1){
        error_handling("accept() error!");
    }

    char message[]="Hello World!";

    //write()用于传输数据
    write(clnt_sock,message,sizeof(message));

    close(clnt_sock);
    close(serv_sock);
    return 0;
}
void error_handling(char const* message){
    fputs(message,stderr);
    fputc('\n',stderr);
    exit(1);
}
```
### 构建打电话套接字
服务器端创建的套接字称为`服务器端套接字`或`监听(listening)套接字`.

接下来介绍的套接字是用于连接请求的`客户端套接字`.

这里总结一下:
1. 主动监听`->`服务端套接字
2. 主动连接请求`->`客户端套接字

主动给其他人打电话(发起连接请求)的函数还未介绍,
这就是客户端套接字调用的`connect`函数.

#### `connect()`发起连接请求
```c
#include<sys/socket.h>
int connect(int sockfd,struct sockaddr* serv_addr,socklen_t addrlen);
    //成功时返回0
    //失败时返回-1
```
#### 客户端发起连接请求的过程
客户端使用套接字发起连接请求的过程,比服务端监听接收请求的过程,步骤更简单.

客户端发起连接请求的过程:
1. 调用`socket()`创建套接字
2. 调用`connect()`向服务器端发送连接请求

下面给出客户端,该客户端的业务逻辑:
1. 调用`socket()`和`connect()`
2. 与服务器端共同运行以收发字符串数据
#### `hello_client.c`
```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<unistd.h>
#include<arpa/inet.h>
#include<sys/socket.h>

void error_handling(char const* message);

int main(int argc,char* argv[]){

    if(argc!=3){
        printf("Usage:%s <IP> <port>\n",argv[0]);
        exit(1);
    }

    int sock;

    //调用socket()创建套接字
    //判断套接字是服务器端套接字还是客户端套接字的方法
    //如果套接字创建之后紧接着调用bind() & listen(),就是服务器端套接字
    //如果套接字创建之后调用connect(),就是客户端套接字
    sock=socket(PF_INET,SOCK_STREAM,0);
    if(sock==-1){
        error_handling("socket() error!");
    }

    struct sockaddr_in serv_addr;
    memset(&serv_addr,0,sizeof(serv_addr));
    serv_addr.sin_family=AF_INET;
    serv_addr.sin_addr.s_addr=inet_addr(argv[1]);
    serv_addr.sin_port=htons(atoi(argv[2]));

    //调用connect()向服务器端发起连接请求
    if(connect(sock,(struct sockaddr*)&serv_addr,sizeof(serv_addr))==-1){
        error_handling("connect() error!");
    }

    int str_len;
    char message[30];
    str_len=read(sock,message,sizeof(message)-1);
    if(str_len==-1){
        error_handling("read() error!");
    }
    printf("Message from server : %s \n",message);

    close(sock);
    return 0;
}
void error_handling(char const* message){
    fputs(message,stderr);
    fputc('\n',stderr);
    exit(1);
}
```
### 在`Linux`平台下运行
`hello_server.c`和`hello_client.c`都应在`Linux`环境中编译执行.

`C`语言编译器`GCC`编译器对`hello_server.c`进行编译:
```bash
#编译hello_server.c文件并生成可执行文件hserver
gcc hello_server.c -o hserver
```
`gcc`命令中的`-o`是也能够来指定可执行文件名的可选参数.

因此,编译后将在当前路径下生成名为`hserver`的可执行文件

执行如下的命令运行可执行程序:
```bash
#运行当前目录下的hserver文件
./hserver
```
服务器端需要在运行时接收客户端的连接请求,因此,服务器端需要先运行.
```bash
#运行服务器端
gcc hello_server.c -o hserver
./hserver 9190
```
正常情况下,服务器端会因为调用`accept()`,在处于未监听到连接请求时陷入等待状态.

等到有连接请求,`accept()`才会返回.
```bash
#运行客户端
gcc hello_client.c -o hclient
./hclient 127.0.0.1 9190
```
客户端的运行结果:
```bash
Message from server : Hello World! 
```
`127.0.0.1`是运行示例用的计算机(本机计算机)的`IP`地址
(常用于指代实际的本机`IP`地址).

如果在同一台计算机运行服务器端和客户端,将采用这种连接方式.

但如果服务器端与客户端在不同的计算机中运行,
则应采用服务器端所在计算机的`IP`地址.

#### `hello_server`无法立即重新运行的`Bug`
当服务器端和客户端运行结束之后,立即重新运行服务器端程序,
会发现服务器端提示如下错误:
```bash
bind() error!
```
等待一段时间后,再次重新运行服务器端程序,发现错误消失了.

这是怎么一回事呢?

这里给出一个可能的解决办法:

上面的服务器端无法立即重新运行,
如果希望立即重新运行,需要更改端口号为`9190`之外的其他端口号.

现在不必对此感到意外,原因后面会讲.
## 1.2 基于`Linux`的文件操作
在`Linux`操作系统中,`socket`被认为是文件的一种.

因此在网络数据传输中可以使用文件`I/O`相关函数来操作`socket`.

`Windows`与`Linux`不同,是区分`socket`和文件的.

因此在`Windows`中需要调用特殊的数据传输相关函数来操作`socket`.

