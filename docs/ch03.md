# 第三章 地址族与数据序列
本章重点讲解给套接字分配`IP`地址和端口号.
## 3.1 分配给套接字的`IP`地址与端口号
`IP`是`Internet Protocol`(网络协议)的简写.
为了收发数据而`分配给计算机的值`.

`端口号`是为了区分程序中创建的套接字而`分配给套接字的序号`.
### 网络地址(`Internet Address`)
`IP`地址分为2类:
1. `IPv4`(`Internet Protocol version 4`) `4`字节地址族
2. `IPv6`(`Internet Protocol version 6`) `6`字节地址族

`IPv4`与`IPv6`的差别主要是`IP`地址所用的字节数.

`IPv6`是为了应对`IPv4`地址耗尽问题而提出的标准.

`IPv4`标准的4字节`IP`地址包含网络地址和主机(指的是计算机本身)地址,
且分为`A`,`B`,`C`,`D`,`E`等类型,`E`类地址一般不会被使用,先略去不讲.
### `IPv4`地址族
```txt
A类  [1字节|1字节|1字节|1字节]
      \_ _/ \_______ _______/
        V           V
     网络ID      主机ID

B类  [1字节|1字节|1字节|1字节]
      \____ ____/ \____ ____/
           V           V
        网络ID      主机ID

C类  [1字节|1字节|1字节|1字节]
      \_______ _______/ \_ _/
              V           V
           网络ID      主机ID

D类  [1字节|1字节|1字节|1字节]
      \__________ __________/
                 V
            多播IP地址
```
### 基于`IP`地址的数据传递过程
```txt
                                        +-----MID.COM 203.211.172-----------+
                                        |                                   |
                                        |         [103号计算机]             |
                                        |               ^                   |
        +向203.211.172.103传输的数据->[路由器]----+-----+---------+         |
        |                               |         V               V         |
        |                               |    [102号计算机]  [104号计算机]   |
        |                               +-----------------------------------+
[计算机]+                                                                    
        |                               +-----SEMI.COM 203.211.217----------+
        |                               |                                   |
        |                               |    [201号计算机]  [203号计算机]   |
        |                               |         ^               ^         |
        +向203.211.217.202传输的数据->[路由器]----+-----+---------+         |
                                        |               V                   |
                                        |         [202号计算机]             |
                                        +-----------------------------------+
```
某主机向`203.211.172.103`和`203.211.217.202`传输数据,
其中`203.211.172`和`203.211.217`为该网络的网络地址.

`向相应网络传输数据`实际上是向构成网络的路由器(`Router`)或交换机(`Switch`)
传递数据,由接收数据的路由器根据数据中的主机地址向目标主机传递数据.

这里有一个隐含的数据存储的信息,不知道读者发现了没有:

例如`IP`地址`203.211.172.103`在内存中是如何存储的呢?
```txt
index: 0   1   2   3
value:[203|211|172|103]
```
是上面的这种存储方式吗?谜底我们后面会揭晓.
#### 路由器和交换机
构建网络的过程中需要一种物理设备完成外网和本网主机之间的连接.
完成连接并进行数据交换的便是路由器或交换机.

它们实际上是一种计算机,交换机比路由器功能要简单一些.
### 网络地址分类与主机地址边界
只需要通过`IP`地址第一个字节的数字就可以判断`IP`地址的类型,
进而可以判断网络地址所占的字节数,
因为`IP`地址在设计的时候就根据`IP`地址的边界区分了网络地址:

`A`类地址的首字节范围:`0`~`127`

翻译成8位二进制(1字节):`0000 0000`~`0111 1111`

规律是二进制以`0`为开头.

`B`类地址的首字节范围:`128`~`191`

翻译成8位二进制(1字节):`1000 0000`~`1011 1111`

规律是二进制以`10`为开头.

`C`类地址的首字节范围:`192`~`223`

翻译成8位二进制(1字节):`1100 0000`~`1101 1111`

规律是二进制以`110`为开头.
### 用于区分套接字的端口号
#### 数据分配过程
```txt
[PORT 1020 套接字]<---+                +---to PORT 1020
                      +-由操作系统分配-+
[PORT 2040 套接字]<---+                +---to PORT 2040
```
计算机中一般配有`NIC`(`Network Interface Card`,网络接口卡)数据传输设备.
通过`NIC`向计算机内部传输数据时会用到`IP`地址.

操作系统负责把传递到内部的数据适当分配给套接字,
这时需要使用端口号来区分不同的套接字.

通过`NIC`接收的数据内存在`端口号`信息,操作系统需要参照端口号
把数据传输给端口号对应的套接字.

端口号是在同一操作系统内为区分不同套接字而设置的,
因此无法将1个端口号分配给不同的套接字.

端口号由16位二进制构成(2字节),可分配的端口号范围是`0`~`65535`.
但`0`~`1023`是知名端口(`Well-known PORT`),一般分配给特定应用程序,
所以应当分配此范围之外的值.

注意:尽量分配`1024`~`65535`的端口号使用.

另外,虽然端口号不能重复,但是`TCP`套接字和`UDP`套接字不会共用端口号.

例如:如果某`TCP`套接字使用了`9190`号端口,则其他`TCP`套接字就无法使用`9190`端口,
但是`UDP`套接字可以使用`9190`端口,并且和`TCP`的`9190`端口互不打扰.

总结:数据传输目标地址需要同时包含`IP`地址和端口号,只有这样,
数据才会被传输到最终的目的地(应用程序套接字).

这里我发现一个新问题:
给出一个端口号,我如何才能得知它使用`TCP`通信还是`UDP`通信呢?
首先从端口号信息是无法看出这一点的,
我只能分别使用`TCP`套接字和`UDP`套接字对服务器发起请求来尝试一下了.
## 3.2 地址信息的表示
`IP`地址和端口号在应用程序中是如何表示的呢?
### 表示`IPv4`地址的结构体
### `struct sockaddr_in{}`
```c
struct sockaddr_in{
    sa_family_t    sin_family ; //地址族(Address Family),简写为`AF_`
    uint16_t       sin_port   ; //16位(2字节)TCP/UDP端口号
    struct in_addr sin_addr   ; //32位(4字节)IPv4地址
    char           sin_zero[8]; //不使用
};
```
### `struct in_addr{}`
```c
struct in_addr{
    in_addr_t       s_addr    ; //32位(4字节)IPv4地址
};
```
上面的两个结构体中出现了一些类型:`sa_family_t`,`uint16_t`,`in_addr_t`.

这些类型可以参考`POSIX`
(`Portable Operating System Interface`,可移植操作系统接口).

`POSIX`是为`UNIX`系列操作系统设立的标准,它定义了一些其他的数据类型.
### `POSIX`中定义的数据类型
数据类型名称 |数据类型说明                      |声明的头文件
:------------|:---------------------------------|:-------------
`int8_t`     |signed 8-bit int                  |`sys/types.h`
`uint8_t`    |unsigned 8-bit int(unsigned char) |`sys/types.h`
`int16_t`    |signed 16-bit int                 |`sys/types.h`
`uint16_t`   |unsigned 16-bit int(unsigned char)|`sys/types.h`
`int32_t`    |signed 32-bit int                 |`sys/types.h`
`uint32_t`   |unsigned 32-bit int(unsigned char)|`sys/types.h`
`sa_family_t`|地址族(Address Family)            |`sys/socket.h`
`socklen_t`  |长度(length of struct)            |`sys/socket.h`
`in_addr_t`  |IP地址,声明为`uint32_t`           |`netinet/in.h`
`in_port_t`  |端口号,声明为`uint16_t`           |`netinet/in.h`
### `struct sockaddr_in{}`的成员分析
#### 成员`sin_family`
##### `地址族`
每种协议族适用的地址族不同.
`IPv4`使用4字节地址族,`IPv6`使用16字节地址族.

地址族(`Address Family`)|含义
:----------------------:|:---------------------------------
`AF_INET`               |`IPv4`网络协议中使用的地址族
`AF_INET6`              |`IPv6`网络协议中使用的地址族
`AF_LOCAL`              |本地通信中采用的`UNIX`协议的地址族
#### 成员`sin_port`
该成员保存16位二进制(2字节)端口号,重点在于它以网络字节序保存.(稍后会给出详细说明)
#### 成员`sin_addr`
该成员保存32位二进制(4字节)`IP`地址信息,且也以网络字节序保存.
```txt
struct in_addr <=> in_addr_t <=> uint32_t
```
可以简单理解为一个4字节的无符号整数类型.
#### 成员`sin_zero`
无特征含义.只是为了使结构体`sockaddr_in`的大小与`sockaddr`结构体保持一致.
必须填充为0,否则无法得到想要的结果.

从之前的服务器端代码中不难发现,我们在使用`struct sockaddr_in`的时候,
需要进行强制类型转换为`struct sockaddr`进行信息绑定.
```c
struct sockaddr_in serv_addr;
//....
if(bind(serv_sock,(struct sockaddr*)&serv_addr,sizeof(serv_addr))==-1){
    error_handling("bind() error!");
}
//....
```
下面给出`struct sockaddr{}`的定义.
#### `struct sockaddr{}`
```c
struct sockaddr{
    sa_family_t sin_family ; // 地址族(Address Family)
    char        sa_data[14]; // 地址信息
};
```
此结构体成员`sa_data`保存的地址信息需包含`IP`地址和端口号,剩余部分应填充`0`.
这也是`bind`函数要求的.

从这个结构体的成员来看,
直接填充`struct sockaddr{}`包含的地址信息是非常麻烦的,
继而就有了新的结构体`sockaddr_in`,来简化填充流程.
填充完毕之后,只需要强制类型转换为`sockaddr`型的结构体变量,
再传递给`bind`函数即可.
#### `struct sockaddr_in{}.sa_family=AF_INET`的真实含义
提出一个问题:

从`struct sockaddr_in{}`的成员信息来看,
这是一个专门为`IPv4`设计的,
但是我们却还需要给`sin_family`成员变量赋值`AF_INET`,来表示这是`IPv4`地址.
这是不是有点多余?

注意:`struct sockaddr{}`内部也有同名的`sa_family`成员.

原因很简单,因为`struct sockaddr`不是专门为`IPv4`设计的,
`struct sockaddr_in`仅仅是为了`IPv4`地址填充而创造的工具类.
## 3.3 网络字节序与地址变换
在不同的`CPU`中,4字节的整数型值(32位`IPv4`地址)在内存空间的保存方式可能是不同的.
有些`CPU`是顺序保存.

例如数字1的内存存储方式:
```txt
00000000 00000000 00000000 00000001
```
而另外一些`CPU`则以倒序保存.
```txt
00000001 00000000 00000000 00000000
```
如果不考虑上述问题,收发数据的时候就会发生问题.
这不仅仅局限在`IP`地址的传输上,甚至是数据包的传输.

因为保存顺序的不同意味着接收数据的解析顺序也不同.

注意这里的字节序问题仅仅是存在在传输多字节数据类型
(例如:`int16_t`,`int32_t`等)中,
在单字节数据类型(例如:`char`,`uint8_t`等)及其序列中,数据都是顺序存放的.
### 字节序(`Order`)与网络字节序
`CPU`向内存保存数据的方式有2种,这意味着`CPU`解析数据的方式也分为2种.
1. 大端序(`Big Endian`):高位字节存放在低位地址.

例如数字`0x12345678`(16进制表示的4字节数据)的内存存储方式:

起始地址是`0x20`.
```txt
address: 0x20 0x21 0x22 0x23
value  :[0x12|0x34|0x56|0x78]
```
2. 小端序(`Little Endian`):低位字节存放在高位地址.

例如数字`0x12345678`(16进制表示的4字节数据)的内存存储方式:

起始地址是`0x20`.
```txt
address: 0x20 0x21 0x22 0x23
value  :[0x78|0x56|0x34|0x12]
```
每种`CPU`的数据保存方式不一定相同.

代表`CPU`数据保存方式的字节序成为`主机字节序`(`Host Byte Order`).
#### 字节序问题
```txt
[大端序系统]--->[0x34]->[0x12]--->[小端序系统]
0x1234传输                        0x1234接收,但解析为0x3412!
```
正是因为上述问题的出现,在通过网络传输数据时约定字节序的统一方式尤为重要.

这种约定称为`网络字节序`(`Network Byte Order`),非常简单----统一为大端序.

即先把数据组(多字节数据类型及其序列)转化为大端序格式再进行网络传输.
### 字节序转换(`Endian Conversions`)
相信大家已经理解了为何要在填充`sockaddr_in`结构体前先将数据转换为为网络字节序,
接下来介绍帮助转换字节序的函数.
```c
//h:Host Byte Order
//n:Network Byte Order
//s:short(linux:2字节数据)
//l:long(linux:4字节数据)
unsigned short htons(unsigned short);
unsigned short ntohs(unsigned short);
unsigned long htonl(unsigned long);
unsigned long ntohl(unsigned long);
```
思考如下一个问题:
如果系统是大端序的,为`sockaddr_in`结构体变量赋值前就不需要转换字节序了吧?

这么说也不能说错,但是代码应该考虑系统兼容性,
因此,有必要编写与机器无关的统一代码,
即便是在大端序系统中,最好也经过主机字节序转换为网络字节序的过程.
当然,此时如果主机字节序与网络字节序相同,不会有任何变化.
### `endian_conv.c`
```c
#include<stdio.h>
#include<arpa/inet.h>

int main(int argc,char* argv[]){

    //变量host_port和host_addr各保存2个字节,4个字节的数据
    //当然,若运行程序的CPU不同,则保存的字节序也不同
    unsigned short host_port=0x1234;
    unsigned long host_addr=0x12345678;

    unsigned short net_port;
    unsigned long net_addr;

    //将变量host_port和host_addr中的数据转化为网络字节序
    //若运行环境为小端序CPU,则按改变之后的字节序保存
    net_port=htons(host_port);
    net_addr=htonl(host_addr);

    printf("Host ordered port: %#x \n",host_port);
    printf("Network ordered port: %#x \n",net_port);
    printf("Host ordered address: %#lx \n",host_addr);
    printf("Network ordered address: %#lx \n",net_addr);

    return 0;
}
```
#### 运行结果
我的电脑的主机字节序号采用的是小端序.运行结果如下:
```txt
Host ordered port: 0x1234
Network ordered port: 0x3412
Host ordered address: 0x12345678
Network ordered address: 0x78563412
```
### 数据在传输之前都要经过字节序转换吗?
此时有读者认为:既然传输`IP`地址和端口号需要采用网络字节序,
那么在网络传输数据前是不是应该直接把数据转换为网络字节序,
接收的数据也需要转换为主机字节序再保存.

如果数据收发过程中没有自动转换机制,那当然需要程序员手动转换.
这个光想象就让人觉得可怕,难道真要强求程序员做这些事情吗?
实际上是有必要的,这个过程中可以通过封装`read`,`write`,`send`,`recv`函数来解决.

除了向`sockaddr_in`结构体变量填充数据外,
传输多字节数据类型及其序列的情况都需考虑字节序问题.

(注意:这里书籍的原文的表述是完全错误的,我上面表达的观点才是正确的)
## 3.4 网络地址的初始化与分配
### 将字符串信息转换为网络字节序的整数型
`sockaddr_in`中保存地址信息的成员为32位整数型.
对于`IP`地址的表示,我们熟悉的是点分十进制表示法(`Dotted Decimal Notation`),
而非整数型数据表示法.

例如:在填写时需要将`IP`地址`201.211.214.36`(点分十进制表示法)
转换为32位4字节整数型数据.

`linux`系统提供了如下的函数接口来进行字符串形式到32位整数型的转换,
并在转换类型的同时进行网络字节序转换.
### `inet_addr()`
```c
#include<arpa/inet.h>

in_addr_t inet_addr(char const* string);
    //成功时返回32位大端序整数型值
    //失败时返回INADDR_NONE
```
这里的`in_addr_t`类型已在前文讲过,是专门用来表示`IP`地址的32位整数型类型.
### `inet_addr.c`
```c
#include<stdio.h>
#include<arpa/inet.h>

int main(int argc,char* argv[]){

    char* addr1="1.2.3.4";
    //一个字节能表示的最大无符号正整数是255
    //也就是说下面的地址是一个错误的IP地址
    //由此验证一下inet_addr()的错误检测能力
    char* addr2="1.2.3.256";

    unsigned long conv_addr=inet_addr(addr1);
    if(conv_addr==INADDR_NONE){
        printf("Error occured! \n");
    }else{
        printf("Network ordered integer addr: %#lx \n",conv_addr);
        //可以这样验证字节顺序
        unsigned char *p=(unsigned char*)&conv_addr;
        printf("字节顺序:%d.%d.%d.%d\n",p[0],p[1],p[2],p[3]);
    }

    conv_addr=inet_addr(addr2);
    if(conv_addr==INADDR_NONE){
        printf("Error occured! \n");
    }else{
        printf("Network ordered integer addr: %#lx \n",conv_addr);
        //可以这样验证字节顺序
        unsigned char *p=(unsigned char*)&conv_addr;
        printf("字节顺序:%d.%d.%d.%d\n",p[0],p[1],p[2],p[3]);
    }
    return 0;
}
```
#### 运行结果
```txt
Network ordered integer addr: 0x4030201
字节顺序:1.2.3.4
Error occured!
```
思考一个问题:输出结果为什么不是`0x01020304`?

因为虽然`addr1`是按照网络字节序保存的,
但是使用`printf()`打印`addr1`的时候使用的是主机字节序进行解析多字节数据的.
我的电脑的主机序是小端序,所以解析顺序和网络字节序完全相反.
因此输出结果是`0x4030201`,
但是看下面的字节顺序就是正常的大端序了.
### `inet_aton()`
下面介绍一个功能上与`inet_addr()`完全相同,而且使用频率更高更好用的函数接口.
```c
#include<arpa/inet.h>

//string:含有需要转换的IP地址信息的字符串地址值
//addr:将保存转换结果的in_addr结构体变量的地址值
int inet_aton(char const* string,struct in_addr* addr);
    //成功时返回1(true)
    //失败时返回0(false)
```
下面通过一个使用案例来了解一下上述函数接口的具体使用方式.
### `inet_aton.c`
```c
#include<stdio.h>
#include<stdlib.h>
#include<arpa/inet.h>

void error_handling(char* message);

int main(int argc,char* argv[]){

    char* addr="127.232.124.79";
    struct sockaddr_in addr_inet;

    //inet_aton()的第二个参数要求得到in_addr型变量的地址值
    //这就省去了手动保存中间IP地址信息整型值的过程
    if(!inet_aton(addr,&addr_inet.sin_addr)){
        error_handling("Conversion error");
    }else{
        printf("Network ordered integer addr: %#x \n",
            addr_inet.sin_addr.s_addr);
        unsigned char *p=(unsigned char*)&(addr_inet.sin_addr.s_addr);
        printf("字节顺序:%d.%d.%d.%d\n",p[0],p[1],p[2],p[3]);
    }

    return 0;
}

void error_handling(char* message){
    fputs(message,stderr);
    fputc('\n',stderr);
    exit(1);
}
```
#### 运行结果
```txt
Network ordered integer addr: 0x4f7ce87f 
字节顺序:127.232.124.79
```
### `inet_ntoa()`
这里介绍一个与`inet_aton()`函数正好相反的函数`inet_ntoa()`.
此函数可以把网络字节序整数型`IP`地址转换成我们熟悉的字符串形式.
```c
#include<arpa/inet.h>

char* inet_ntoa(struct in_addr adr);
    //成功时返回转换的字符串地址值
    //失败时返回-1
```
注意事项:

该函数并未想程序员要求分配内存地址,
返回字符串地址意味着字符串已保存到内存空间.

因此,在调用完该函数之后,应立即将字符串信息复制到其他内存空间.

因为,若再次调用`inet_ntoa()`,则有可能覆盖之前保存的字符串信息.
### `inet_ntoa.c`
```c
#include<stdio.h>
#include<string.h>
#include<arpa/inet.h>

int main(int argc,char* argv[]){

    struct sockaddr_in addr1,addr2;
    addr1.sin_addr.s_addr=htonl(0x1020304);
    addr2.sin_addr.s_addr=htonl(0x1010101);

    char* str_ptr;
    //向inet_ntoa函数传递结构体变量addr1中的IP地址信息并调用该函数
    //返回字符串形式的IP地址
    str_ptr=inet_ntoa(addr1.sin_addr);

    char str_arr[20];
    //复制上面返回的IP地址信息
    strcpy(str_arr,str_ptr);
    printf("Dotted-Decimal notation1: %s \n",str_ptr);

    //再次调用inet_ntoa函数
    //测试此时之前返回的字符串地址是否已经设置了新的IP地址信息
    inet_ntoa(addr2.sin_addr);
    printf("Dotted-Decimal notation2: %s \n",str_ptr);
    printf("Dotted-Decimal notation3: %s \n",str_arr);

    return 0;
}
```
#### 运行结果
```txt
Dotted-Decimal notation1: 1.2.3.4
Dotted-Decimal notation2: 1.1.1.1
Dotted-Decimal notation3: 1.2.3.4
```
### 网络地址初始化
现在介绍常见的网络地址信息初始化方法.
```c
struct sockaddr_in addr;
char* serv_ip="211.217.168.13";          //声明IP地址字符串
char* serv_port="9190";                  //声明端口号字符串
memset(&addr,0,sizeof(addr));            //结构体变量addr的所有成员初始化
//上述的初始化也是为了将sockaddr_in结构体的成员sin_zero初始化为0
addr.sin_family=AF_INET;                 //指定地址族
addr.sin_addr.s_addr=inet_addr(serv_ip); //基于字符串的IP地址初始化
addr.sin_port=htons(atoi(serv_port));    //基于字符串的端口号初始化
//上述atoi()函数的作用是将字符串类型的值转换为整数型
```
上述代码中对`IP`地址和端口号使用了硬编码,这并非良策,
实际使用的时候需要从`main()`的函数参数传入`IP`地址和端口号.
### 客户端地址信息初始化
前面所述的网络地址信息初始化过程主要是针对服务器端而非客户端.

例如下面的一个业务:

服务端:请把进入`IP:211.217.168.13`,`PORT:9190`的数据传给我!

客户端:请连接到`IP:211.217.168.13`,`PORT:9190`!

服务端的准备工作:

1. 声明`sockaddr_in`结构体变量

2. 将其初始化为赋予服务器端`IP`和套接字的端口号

3. 调用`bind()`函数

客户端的准备工作:

1. 声明`sockaddr_in`结构体变量

2. 将其初始化为要与之连接的服务器端套接字的`IP`和端口号

3. 调用`connect()`函数

不难发现,无论是在服务器端还是在客户端的业务逻辑中,
我们要初始化的网络地址信息一直都是服务器端的`IP`和服务器端套接字的端口号.
### `INADDR_ANY`
在服务器端中,每次创建服务器端套接字都要输入`IP`地址,这有点繁琐.
我们可以使用`INADDR_ANY`来简化这个操作.
```c
struct sockaddr_in addr;
char* serv_port="9190";
memset(&addr,0,sizeof(addr));
addr.sin_family=AF_INET;
addr.sin_addr.s_addr=htonl(INADDR_ANY);
addr.sin_port=htons(atoi(serv_port));
```
使用`INADDR_ANY`的好处:
若采用这种方式,则可自动获取服务器端的计算机`IP`地址.
而且,相比于硬编码固定的服务器端`IP`地址,
如果同一台计算机已分配多个`IP`地址
(多宿主(`Multi-homed`)计算机,一般路由器属于这一类),
则此时如果使用了`INADDR_ANY`,
只要端口号一致,就可以从不同的`IP`地址接收数据.
因此,服务器端中优先考虑这种方式.
而客户端中除非带有一部分服务器端功能,否则一般不会采用上述方式.
#### 创建服务器端套接字时需要`IP`地址的原因
同一个计算机中可以分配多个`IP`地址,
实际`IP`地址的个数与计算机中安装的`NIC`的数量相等.

即使是服务器端套接字,
也需要决定应该接收哪个`IP`传来的(哪个`NIC`传来的)数据,
因此,服务器端套接字初始化过程中要求`IP`地址信息.

另外,计算机若只有一个`NIC`,则直接使用`INADDR_ANY`.
### 第1章的`hello_server.c`,`hello_client.c`运行过程
在之前的服务器端`hello_server.c`中只需要向`main()`函数传递一个参数,
这个参数传递端口号.
但是读者有没有思考过下面的问题:

为什么不使用传递2个参数的方式,
第一个参数传递服务器端的`IP`地址,第二个参数传递服务器端套接字的端口号呢?

因为在服务器端代码中可以通过`INADDR_ANY`直接指定服务器端的`IP`地址.
执行如下的命令生成服务器端可执行文件,并执行.
```bash
gcc hello_server.c -o hserver
./hserver 9190
```
执行如下的命令生成客户端可执行文件,并执行.
```bash
gcc hello_client.c -o hclient
./hclient 127.0.0.1 9190
```
从上面的客户端执行过程不难发现,与服务器端运行方式相比,
最大的区别是传递了`IP`地址信息.
