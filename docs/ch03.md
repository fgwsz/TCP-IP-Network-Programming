# 第三章 地址族与数据序列
本章重点讲解给套接字分配`IP`地址和端口号.
## 3.1 分配给套接字的`IP`地址与端口号
`IP`是`Internet Protocol`(网络协议)的简写.
为了收发数据而`分配给计算机的值`.

`端口号`是为了区分程序中创建的套接字而`分配给套接字的序号`.
### 网络地址(`Internet Address`)
`IP`地址分为2类:
1. `IPv4`(`Internet Protocol version 4`) `4`字节地址族
2. `IPv6`(`Internet Protocol version 6`) `6`字节地址族

`IPv4`与`IPv6`的差别主要是`IP`地址所用的字节数.

`IPv6`是为了应对`IPv4`地址耗尽问题而提出的标准.

`IPv4`标准的4字节`IP`地址包含网络地址和主机(指的是计算机本身)地址,
且分为`A`,`B`,`C`,`D`,`E`等类型,`E`类地址一般不会被使用,先略去不讲.
### `IPv4`地址族
```txt
A类  [1字节|1字节|1字节|1字节]
      \_ _/ \_______ _______/
        V           V
     网络ID      主机ID

B类  [1字节|1字节|1字节|1字节]
      \____ ____/ \____ ____/
           V           V
        网络ID      主机ID

C类  [1字节|1字节|1字节|1字节]
      \_______ _______/ \_ _/
              V           V
           网络ID      主机ID

D类  [1字节|1字节|1字节|1字节]
      \__________ __________/
                 V
            多播IP地址
```
### 基于`IP`地址的数据传递过程
```txt
                                        +-----MID.COM 203.211.172-----------+
                                        |                                   |
                                        |         [103号计算机]             |
                                        |               ^                   |
        +向203.211.172.103传输的数据->[路由器]----+-----+---------+         |
        |                               |         V               V         |
        |                               |    [102号计算机]  [104号计算机]   |
        |                               +-----------------------------------+
[计算机]+                                                                    
        |                               +-----SEMI.COM 203.211.217----------+
        |                               |                                   |
        |                               |    [201号计算机]  [203号计算机]   |
        |                               |         ^               ^         |
        +向203.211.217.202传输的数据->[路由器]----+-----+---------+         |
                                        |               V                   |
                                        |         [202号计算机]             |
                                        +-----------------------------------+
```
某主机向`203.211.172.103`和`203.211.217.202`传输数据,
其中`203.211.172`和`203.211.217`为该网络的网络地址.

`向相应网络传输数据`实际上是向构成网络的路由器(`Router`)或交换机(`Switch`)
传递数据,由接收数据的路由器根据数据中的主机地址向目标主机传递数据.

这里有一个隐含的数据存储的信息,不知道读者发现了没有:

例如`IP`地址`203.211.172.103`在内存中是如何存储的呢?
```txt
index: 0   1   2   3
value:[203|211|172|103]
```
是上面的这种存储方式吗?谜底我们后面会揭晓.
#### 路由器和交换机
构建网络的过程中需要一种物理设备完成外网和本网主机之间的连接.
完成连接并进行数据交换的便是路由器或交换机.

它们实际上是一种计算机,交换机比路由器功能要简单一些.
### 网络地址分类与主机地址边界
只需要通过`IP`地址第一个字节的数字就可以判断`IP`地址的类型,
进而可以判断网络地址所占的字节数,
因为`IP`地址在设计的时候就根据`IP`地址的边界区分了网络地址:

`A`类地址的首字节范围:`0`~`127`

翻译成8位二进制(1字节):`0000 0000`~`0111 1111`

规律是二进制以`0`为开头.

`B`类地址的首字节范围:`128`~`191`

翻译成8位二进制(1字节):`1000 0000`~`1011 1111`

规律是二进制以`10`为开头.

`C`类地址的首字节范围:`192`~`223`

翻译成8位二进制(1字节):`1100 0000`~`1101 1111`

规律是二进制以`110`为开头.
### 用于区分套接字的端口号
#### 数据分配过程
```txt
[PORT 1020 套接字]<---+                +---to PORT 1020
                      +-由操作系统分配-+
[PORT 2040 套接字]<---+                +---to PORT 2040
```
计算机中一般配有`NIC`(`Network Interface Card`,网络接口卡)数据传输设备.
通过`NIC`向计算机内部传输数据时会用到`IP`地址.

操作系统负责把传递到内部的数据适当分配给套接字,
这时需要使用端口号来区分不同的套接字.

通过`NIC`接收的数据内存在`端口号`信息,操作系统需要参照端口号
把数据传输给端口号对应的套接字.

端口号是在同一操作系统内为区分不同套接字而设置的,
因此无法将1个端口号分配给不同的套接字.

端口号由16位二进制构成(2字节),可分配的端口号范围是`0`~`65535`.
但`0`~`1023`是知名端口(`Well-known PORT`),一般分配给特定应用程序,
所以应当分配此范围之外的值.

注意:尽量分配`1024`~`65535`的端口号使用.

另外,虽然端口号不能重复,但是`TCP`套接字和`UDP`套接字不会共用端口号.

例如:如果某`TCP`套接字使用了`9190`号端口,则其他`TCP`套接字就无法使用`9190`端口,
但是`UDP`套接字可以使用`9190`端口,并且和`TCP`的`9190`端口互不打扰.

总结:数据传输目标地址需要同时包含`IP`地址和端口号,只有这样,
数据才会被传输到最终的目的地(应用程序套接字).

这里我发现一个新问题:
给出一个端口号,我如何才能得知它使用`TCP`通信还是`UDP`通信呢?
首先从端口号信息是无法看出这一点的,
我只能分别使用`TCP`套接字和`UDP`套接字对服务器发起请求来尝试一下了.
## 3.2 地址信息的表示
`IP`地址和端口号在应用程序中是如何表示的呢?
### 表示`IPv4`地址的结构体
### `struct sockaddr_in{}`
```c
struct sockaddr_in{
    sa_family_t    sin_family ; //地址族(Address Family),简写为`AF_`
    uint16_t       sin_port   ; //16位(2字节)TCP/UDP端口号
    struct in_addr sin_addr   ; //32位(4字节)IPv4地址
    char           sin_zero[8]; //不使用
};
```
### `struct in_addr{}`
```c
struct in_addr{
    in_addr_t       s_addr    ; //32位(4字节)IPv4地址
};
```
上面的两个结构体中出现了一些类型:`sa_family_t`,`uint16_t`,`in_addr_t`.

这些类型可以参考`POSIX`
(`Portable Operating System Interface`,可移植操作系统接口).

`POSIX`是为`UNIX`系列操作系统设立的标准,它定义了一些其他的数据类型.
### `POSIX`中定义的数据类型
数据类型名称 |数据类型说明                      |声明的头文件
:------------|:---------------------------------|:-------------
`int8_t`     |signed 8-bit int                  |`sys/types.h`
`uint8_t`    |unsigned 8-bit int(unsigned char) |`sys/types.h`
`int16_t`    |signed 16-bit int                 |`sys/types.h`
`uint16_t`   |unsigned 16-bit int(unsigned char)|`sys/types.h`
`int32_t`    |signed 32-bit int                 |`sys/types.h`
`uint32_t`   |unsigned 32-bit int(unsigned char)|`sys/types.h`
`sa_family_t`|地址族(Address Family)            |`sys/socket.h`
`socklen_t`  |长度(length of struct)            |`sys/socket.h`
`in_addr_t`  |IP地址,声明为`uint32_t`           |`netinet/in.h`
`in_port_t`  |端口号,声明为`uint16_t`           |`netinet/in.h`
### `struct sockaddr_in{}`的成员分析
#### 成员`sin_family`
##### `地址族`
每种协议族适用的地址族不同.
`IPv4`使用4字节地址族,`IPv6`使用16字节地址族.

地址族(`Address Family`)|含义
:----------------------:|:---------------------------------
`AF_INET`               |`IPv4`网络协议中使用的地址族
`AF_INET6`              |`IPv6`网络协议中使用的地址族
`AF_LOCAL`              |本地通信中采用的`UNIX`协议的地址族
#### 成员`sin_port`
该成员保存16位二进制(2字节)端口号,重点在于它以网络字节序保存.(稍后会给出详细说明)
#### 成员`sin_addr`
该成员保存32位二进制(4字节)`IP`地址信息,且也以网络字节序保存.
```txt
struct in_addr <=> in_addr_t <=> uint32_t
```
可以简单理解为一个4字节的无符号整数类型.
#### 成员`sin_zero`
无特征含义.只是为了使结构体`sockaddr_in`的大小与`sockaddr`结构体保持一致.
必须填充为0,否则无法得到想要的结果.

从之前的服务器端代码中不难发现,我们在使用`struct sockaddr_in`的时候,
需要进行强制类型转换为`struct sockaddr`进行信息绑定.
```c
struct sockaddr_in serv_addr;
//....
if(bind(serv_sock,(struct sockaddr*)&serv_addr,sizeof(serv_addr))==-1){
    error_handling("bind() error!");
}
//....
```
下面给出`struct sockaddr{}`的定义.
#### `struct sockaddr{}`
```c
struct sockaddr{
    sa_family_t sin_family ; // 地址族(Address Family)
    char        sa_data[14]; // 地址信息
};
```
此结构体成员`sa_data`保存的地址信息需包含`IP`地址和端口号,剩余部分应填充`0`.
这也是`bind`函数要求的.

从这个结构体的成员来看,
直接填充`struct sockaddr{}`包含的地址信息是非常麻烦的,
继而就有了新的结构体`sockaddr_in`,来简化填充流程.
填充完毕之后,只需要强制类型转换为`sockaddr`型的结构体变量,
再传递给`bind`函数即可.
#### `struct sockaddr_in{}.sa_family=AF_INET`的真实含义
提出一个问题:

从`struct sockaddr_in{}`的成员信息来看,
这是一个专门为`IPv4`设计的,
但是我们却还需要给`sin_family`成员变量赋值`AF_INET`,来表示这是`IPv4`地址.
这是不是有点多余?

注意:`struct sockaddr{}`内部也有同名的`sa_family`成员.

原因很简单,因为`struct sockaddr`不是专门为`IPv4`设计的,
`struct sockaddr_in`仅仅是为了`IPv4`地址填充而创造的工具类.
## 3.3 网络字节序与地址变换
在不同的`CPU`中,4字节的整数型值(32位`IPv4`地址)在内存空间的保存方式可能是不同的.
有些`CPU`是顺序保存.

例如数字1的内存存储方式:
```txt
00000000 00000000 00000000 00000001
```
而另外一些`CPU`则以倒序保存.
```txt
00000001 00000000 00000000 00000000
```
如果不考虑上述问题,收发数据的时候就会发生问题.
这不仅仅局限在`IP`地址的传输上,甚至是数据包的传输.

因为保存顺序的不同意味着接收数据的解析顺序也不同.

注意这里的字节序问题仅仅是存在在传输多字节数据类型
(例如:`int16_t`,`int32_t`等)中,
在单字节数据类型(例如:`char`,`uint8_t`等)及其序列中,数据都是顺序存放的.
### 字节序(`Order`)与网络字节序
`CPU`向内存保存数据的方式有2种,这意味着`CPU`解析数据的方式也分为2种.
1. 大端序(`Big Endian`):高位字节数据存放在低地址.

例如数字`0x12345678`(16进制表示的4字节数据)的内存存储方式:

起始地址是`0x20`.
```txt
address: 0x20 0x21 0x22 0x23
value  :[0x12|0x34|0x56|0x78]
```
2. 小端序(`Little Endian`):低位字节数据存放在低地址.

例如数字`0x12345678`(16进制表示的4字节数据)的内存存储方式:

起始地址是`0x20`.
```txt
address: 0x20 0x21 0x22 0x23
value  :[0x78|0x56|0x34|0x12]
```
每种`CPU`的数据保存方式不一定相同.

代表`CPU`数据保存方式的字节序成为`主机字节序`(`Host Byte Order`).
#### 字节序问题
```txt
[大端序系统]--->[0x34]->[0x12]--->[小端序系统]
0x1234传输                        0x1234接收,但解析为0x3412!
```
正是因为上述问题的出现,在通过网络传输数据时约定字节序的统一方式尤为重要.

这种约定称为`网络字节序`(`Network Byte Order`),非常简单----统一为大端序.

即先把数据组(多字节数据类型及其序列)转化为大端序格式再进行网络传输.
### 字节序转换(`Endian Conversions`)
相信大家已经理解了为何要在填充`sockaddr_in`结构体前先将数据转换为为网络字节序,
接下来介绍帮助转换字节序的函数.
```c
//h:Host Byte Order
//n:Network Byte Order
//s:short(linux:2字节数据)
//l:long(linux:4字节数据)
unsigned short htons(unsigned short);
unsigned short ntohs(unsigned short);
unsigned long htonl(unsigned long);
unsigned long ntohl(unsigned long);
```
思考如下一个问题:
如果系统是大端序的,为`sockaddr_in`结构体变量赋值前就不需要转换字节序了吧?

这么说也不能说错,但是代码应该考虑系统兼容性,
因此,有必要编写与机器无关的统一代码,
即便是在大端序系统中,最好也经过主机字节序转换为网络字节序的过程.
当然,此时如果主机字节序与网络字节序相同,不会有任何变化.
### `endian_conv.c`
```c
#include<stdio.h>
#include<arpa/inet.h>

int main(int argc,char* argv[]){

    //变量host_port和host_addr各保存2个字节,4个字节的数据
    //当然,若运行程序的CPU不同,则保存的字节序也不同
    unsigned short host_port=0x1234;
    unsigned long host_addr=0x12345678;

    unsigned short net_port;
    unsigned long net_addr;

    //将变量host_port和host_addr中的数据转化为网络字节序
    //若运行环境为小端序CPU,则按改变之后的字节序保存
    net_port=htons(host_port);
    net_addr=htonl(host_addr);

    printf("Host ordered port: %#x \n",host_port);
    printf("Network ordered port: %#x \n",net_port);
    printf("Host ordered address: %#lx \n",host_addr);
    printf("Network ordered address: %#lx \n",net_addr);

    return 0;
}
```
#### 运行结果
我的电脑的主机字节序号采用的是小端序.运行结果如下:
```txt
Host ordered port: 0x1234
Network ordered port: 0x3412
Host ordered address: 0x12345678
Network ordered address: 0x78563412
```
### 数据在传输之前都要经过字节序转换吗?
此时有读者认为:既然传输`IP`地址和端口号需要采用网络字节序,
那么在网络传输数据前是不是应该直接把数据转换为网络字节序,
接收的数据也需要转换为主机字节序再保存.

如果数据收发过程中没有自动转换机制,那当然需要程序员手动转换.
这个光想象就让人觉得可怕,难道真要强求程序员做这些事情吗?
实际上是有必要的,这个过程中可以通过封装`read`,`write`,`send`,`recv`函数来解决.

除了向`sockaddr_in`结构体变量填充数据外,
传输多字节数据类型及其序列的情况都需考虑字节序问题.

(注意:这里书籍的原文的表述是完全错误的,我上面表达的观点才是正确的)
## 3.4 网络地址的初始化与分配
### 将字符串信息转换为网络字节序的整数型
`sockaddr_in`中保存地址信息的成员为32位整数型.
对于`IP`地址的表示,我们熟悉的是点分十进制表示法(`Dotted Decimal Notation`),
而非整数型数据表示法.

例如:在填写时需要将`IP`地址`201.211.214.36`(点分十进制表示法)
转换为32位4字节整数型数据.

`linux`系统提供了如下的函数接口来进行字符串形式到32位整数型的转换,
并在转换类型的同时进行网络字节序转换.
### `inet_addr()`
```c
#include<arpa/inet.h>

in_addr_t inet_addr(char const* string);
    //成功时返回32位大端序整数型值
    //失败时返回INADDR_NONE
```
这里的`in_addr_t`类型已在前文讲过,是专门用来表示`IP`地址的32位整数型类型.
### `inet_addr.c`
```c
#include<stdio.h>
#include<arpa/inet.h>

int main(int argc,char* argv[]){

    char* addr1="1.2.3.4";
    //一个字节能表示的最大无符号正整数是255
    //也就是说下面的地址是一个错误的IP地址
    //由此验证一下inet_addr()的错误检测能力
    char* addr2="1.2.3.256";

    unsigned long conv_addr=inet_addr(addr1);
    if(conv_addr==INADDR_NONE){
        printf("Error occured! \n");
    }else{
        printf("Network ordered integer addr: %#lx \n",conv_addr);
        //可以这样验证字节顺序
        unsigned char *p=(unsigned char*)&conv_addr;
        printf("字节顺序:%d.%d.%d.%d\n",p[0],p[1],p[2],p[3]);
    }

    conv_addr=inet_addr(addr2);
    if(conv_addr==INADDR_NONE){
        printf("Error occured! \n");
    }else{
        printf("Network ordered integer addr: %#lx \n",conv_addr);
        //可以这样验证字节顺序
        unsigned char *p=(unsigned char*)&conv_addr;
        printf("字节顺序:%d.%d.%d.%d\n",p[0],p[1],p[2],p[3]);
    }
    return 0;
}
```
#### 运行结果
```txt
Network ordered integer addr: 0x4030201
字节顺序:1.2.3.4
Error occured!
```
思考一个问题:输出结果为什么不是`0x01020304`?

因为虽然`addr1`是按照网络字节序保存的,
但是使用`printf()`打印`addr1`的时候使用的是主机字节序进行解析多字节数据的.
我的电脑的主机序是小端序,所以解析顺序和网络字节序完全相反.
因此输出结果是`0x4030201`,
但是看下面的字节顺序就是正常的大端序了.
### `inet_aton()`
下面介绍一个功能上与`inet_addr()`完全相同,而且使用频率更高更好用的函数接口.
```c
#include<arpa/inet.h>

//string:含有需要转换的IP地址信息的字符串地址值
//addr:将保存转换结果的in_addr结构体变量的地址值
int inet_aton(char const* string,struct in_addr* addr);
    //成功时返回1(true)
    //失败时返回0(false)
```
下面通过一个使用案例来了解一下上述函数接口的具体使用方式.
### `inet_aton.c`
```c
#include<stdio.h>
#include<stdlib.h>
#include<arpa/inet.h>

void error_handling(char* message);

int main(int argc,char* argv[]){

    char* addr="127.232.124.79";
    struct sockaddr_in addr_inet;

    //inet_aton()的第二个参数要求得到in_addr型变量的地址值
    //这就省去了手动保存中间IP地址信息整型值的过程
    if(!inet_aton(addr,&addr_inet.sin_addr)){
        error_handling("Conversion error");
    }else{
        printf("Network ordered integer addr: %#x \n",
            addr_inet.sin_addr.s_addr);
        unsigned char *p=(unsigned char*)&(addr_inet.sin_addr.s_addr);
        printf("字节顺序:%d.%d.%d.%d\n",p[0],p[1],p[2],p[3]);
    }

    return 0;
}

void error_handling(char* message){
    fputs(message,stderr);
    fputc('\n',stderr);
    exit(1);
}
```
#### 运行结果
```txt
Network ordered integer addr: 0x4f7ce87f 
字节顺序:127.232.124.79
```
### `inet_ntoa()`
这里介绍一个与`inet_aton()`函数正好相反的函数`inet_ntoa()`.
此函数可以把网络字节序整数型`IP`地址转换成我们熟悉的字符串形式.
```c
#include<arpa/inet.h>

char* inet_ntoa(struct in_addr adr);
    //成功时返回转换的字符串地址值
    //失败时返回-1
```
注意事项:

该函数并未想程序员要求分配内存地址,
返回字符串地址意味着字符串已保存到内存空间.

因此,在调用完该函数之后,应立即将字符串信息复制到其他内存空间.

因为,若再次调用`inet_ntoa()`,则有可能覆盖之前保存的字符串信息.
### `inet_ntoa.c`
```c
#include<stdio.h>
#include<string.h>
#include<arpa/inet.h>

int main(int argc,char* argv[]){

    struct sockaddr_in addr1,addr2;
    addr1.sin_addr.s_addr=htonl(0x1020304);
    addr2.sin_addr.s_addr=htonl(0x1010101);

    char* str_ptr;
    //向inet_ntoa函数传递结构体变量addr1中的IP地址信息并调用该函数
    //返回字符串形式的IP地址
    str_ptr=inet_ntoa(addr1.sin_addr);

    char str_arr[20];
    //复制上面返回的IP地址信息
    strcpy(str_arr,str_ptr);
    printf("Dotted-Decimal notation1: %s \n",str_ptr);

    //再次调用inet_ntoa函数
    //测试此时之前返回的字符串地址是否已经设置了新的IP地址信息
    inet_ntoa(addr2.sin_addr);
    printf("Dotted-Decimal notation2: %s \n",str_ptr);
    printf("Dotted-Decimal notation3: %s \n",str_arr);

    return 0;
}
```
#### 运行结果
```txt
Dotted-Decimal notation1: 1.2.3.4
Dotted-Decimal notation2: 1.1.1.1
Dotted-Decimal notation3: 1.2.3.4
```
### 网络地址初始化
现在介绍常见的网络地址信息初始化方法.
```c
struct sockaddr_in addr;
char* serv_ip="211.217.168.13";          //声明IP地址字符串
char* serv_port="9190";                  //声明端口号字符串
memset(&addr,0,sizeof(addr));            //结构体变量addr的所有成员初始化
//上述的初始化也是为了将sockaddr_in结构体的成员sin_zero初始化为0
addr.sin_family=AF_INET;                 //指定地址族
addr.sin_addr.s_addr=inet_addr(serv_ip); //基于字符串的IP地址初始化
addr.sin_port=htons(atoi(serv_port));    //基于字符串的端口号初始化
//上述atoi()函数的作用是将字符串类型的值转换为整数型
```
上述代码中对`IP`地址和端口号使用了硬编码,这并非良策,
实际使用的时候需要从`main()`的函数参数传入`IP`地址和端口号.
### 客户端地址信息初始化
前面所述的网络地址信息初始化过程主要是针对服务器端而非客户端.

例如下面的一个业务:

服务端:请把进入`IP:211.217.168.13`,`PORT:9190`的数据传给我!

客户端:请连接到`IP:211.217.168.13`,`PORT:9190`!

服务端的准备工作:

1. 声明`sockaddr_in`结构体变量

2. 将其初始化为赋予服务器端`IP`和套接字的端口号

3. 调用`bind()`函数

客户端的准备工作:

1. 声明`sockaddr_in`结构体变量

2. 将其初始化为要与之连接的服务器端套接字的`IP`和端口号

3. 调用`connect()`函数

不难发现,无论是在服务器端还是在客户端的业务逻辑中,
我们要初始化的网络地址信息一直都是服务器端的`IP`和服务器端套接字的端口号.
### `INADDR_ANY`
在服务器端中,每次创建服务器端套接字都要输入`IP`地址,这有点繁琐.
我们可以使用`INADDR_ANY`来简化这个操作.
```c
struct sockaddr_in addr;
char* serv_port="9190";
memset(&addr,0,sizeof(addr));
addr.sin_family=AF_INET;
addr.sin_addr.s_addr=htonl(INADDR_ANY);
addr.sin_port=htons(atoi(serv_port));
```
使用`INADDR_ANY`的好处:
若采用这种方式,则可自动获取服务器端的计算机`IP`地址.
而且,相比于硬编码固定的服务器端`IP`地址,
如果同一台计算机已分配多个`IP`地址
(多宿主(`Multi-homed`)计算机,一般路由器属于这一类),
则此时如果使用了`INADDR_ANY`,
只要端口号一致,就可以从不同的`IP`地址接收数据.
因此,服务器端中优先考虑这种方式.
而客户端中除非带有一部分服务器端功能,否则一般不会采用上述方式.
#### 创建服务器端套接字时需要`IP`地址的原因
同一个计算机中可以分配多个`IP`地址,
实际`IP`地址的个数与计算机中安装的`NIC`的数量相等.

即使是服务器端套接字,
也需要决定应该接收哪个`IP`传来的(哪个`NIC`传来的)数据,
因此,服务器端套接字初始化过程中要求`IP`地址信息.

另外,计算机若只有一个`NIC`,则直接使用`INADDR_ANY`.
### 第1章的`hello_server.c`,`hello_client.c`运行过程
在之前的服务器端`hello_server.c`中只需要向`main()`函数传递一个参数,
这个参数传递端口号.
但是读者有没有思考过下面的问题:

为什么不使用传递2个参数的方式,
第一个参数传递服务器端的`IP`地址,第二个参数传递服务器端套接字的端口号呢?

因为在服务器端代码中可以通过`INADDR_ANY`直接指定服务器端的`IP`地址.
执行如下的命令生成服务器端可执行文件,并执行.
```bash
gcc hello_server.c -o hserver
./hserver 9190
```
执行如下的命令生成客户端可执行文件,并执行.
```bash
gcc hello_client.c -o hclient
./hclient 127.0.0.1 9190
```
从上面的客户端执行过程不难发现,与服务器端运行方式相比,
最大的区别是传递了`IP`地址信息.

上述使用的`IP`地址`127.0.0.1`是回送地址(`loopback address`),
指的是计算机自身`IP`地址.

在第一章的示例中,服务器端和客户端都是在同一个计算机中运行.
因此,连接目标服务器端的地址为`127.0.0.1`.
如果服务器端和客户端分别在2台计算机中运行,则需要输入服务器端的`IP`地址.
### 向套接字分配网络地址
#### `bind()`
```c
#include<sys/socket.h>

//sockfd:要分配地址信息(IP地址和端口号)的套接字文件描述符
//myaddr:存有地址信息的结构体变量地址值
//addrlen:第二个结构体变量的长度
int bind(int sockfd,struct sockaddr* myaddr,socklen_t addrlen);
    //成功时返回0
    //失败时返回-1
```
如果此函数调用成功,则将第二个参数指定的地址信息分配给第一个参数中的相应套接字.
#### 服务器端常见套接字初始化过程
```c
int serv_sock;
struct sockaddr_in serv_addr;
char* serv_port="9190";

/*创建服务器端套接字(监听套接字)*/
serv_sock=socket(PF_INET,SOCK_STREAM,0);

/*地址信息初始化*/
memset(&serv_addr,0,sizeof(serv_addr));
serv_addr.sin_family=AF_INET;
serv_addr.sin_addr.s_addr=htonl(INADDR_ANY);
serv_addr.sin_port=htons(atoi(serv_port));

/*分配地址信息*/
bind(serv_sock,(struct sockaddr*)&serv_addr,sizeof(serv_addr));
//... ...
```
## 3.5 基于`Windows`的实现
`Windows`中同样存在`sockaddr_in`结构体及各种变换函数,
而且名称/使用方法及含义都相同.
也就无需针对`Windows`平台进行太多修改或改用其他函数.

接下来将之前的几个程序改成`Windows`版本.
### 函数`htons`,`htonl`在`Windows`中的使用
首先给出`Windows`平台下调用`htons`函数和`htonl`函数的示例.

这两个函数的用法与`Linux`平台下的使用并无区别,故省略.
### `endian_conv_win.c`
```cpp
#include<stdio.h>
#include<winsock2.h>

void ErrorHandling(char* message);

int main(int argc,char* argv[]){

    WSADATA wsaData;
    if(WSAStartup(MAKEWORD(2,2),&wsaData)!=0){
        ErrorHandling("WSAStartup() error!");
    }

    unsigned short host_port=0x1234;
    unsigned long host_addr=0x12345678;
    unsigned short net_port;
    unsigned long net_addr;

    net_port=htons(host_port);
    net_addr=htonl(host_addr);

    printf("Host ordered port: %#x \n",host_port);
    printf("Network ordered port: %#x \n",net_port);
    printf("Host ordered address: %#x \n",host_addr);
    printf("Network ordered address: %#x \n",net_addr);

    WSACleanup();
    return 0;
}

void ErrorHandling(char* message){
    fputs(message,stderr);
    fputc('\n',stderr);
    exit(1);
}
```
#### 运行结果
```txt
Host ordered port: 0x1234
Network ordered port: 0x3412
Host ordered address: 0x12345678
Network ordered address: 0x78563412
```
上面的程序相比于`Linux`系统版本,多了进行库初始化的`WSAStartup()`函数调用
和`winsock2.h`头文件的`#include`语句,其他部分没有区别.
### 函数`inet_addr`,`inet_ntoa`在`Windows`中的使用
首先,`Windows`中不存在`inet_aton`函数,故省略.
其次,下面通过一个示例来介绍一下`inet_addr`,`inet_ntoa`函数的使用.
### `inet_adrconv_win.c`
```cpp
#include<stdio.h>
#include<string.h>
#include<winsock2.h>

void ErrorHandling(char* message);

int main(int argc,char* argv[]){
    WSADATA wsaData;
    if(WSAStartup(MAKEWORD(2,2),&wsaData)!=0){
        ErrorHandling("WSAStartup() error!");
    }
    /* inet_addr函数调用示例 */
    {
        char* addr="127.212.124.78";
        unsigned long conv_addr=inet_addr(addr);
        if(conv_addr==INADDR_NONE){
            printf("Error occured!\n");
        }else{
            printf("Network ordered integer addr: %#lx \n");
        }
    }
    /* inet_ntoa函数调用示例 */
    {
        struct sockaddr_in addr;
        char* strPtr;
        char strArr[20];

        addr.sin_addr.s_addr=htonl(0x1020304);
        strPtr=inet_ntoa(addr.sin_addr);
        strcpy(strArr,strPtr);
        printf("Dotted-Decimal notation3 %s \n",strArr);
    }
    WSACleanup();
    return 0;
}
void ErrorHandling(char* message){
    fputs(message,stderr);
    fputc('\n',stderr);
    exit(1);
}
```
#### 运行结果
```txt
Network ordered integer addr: 0x7f00
Dotted-Decimal notation3 1.2.3.4
```
上述示例在`main()`函数体内使用大括号区分了各个函数的调用过程.
### 在`Windows`环境下向套接字分配网络地址
`Windows`中向套接字分配网络地址的过程和`Linux`中完全相同,因为`bind`函数的含义,
参数及返回类型完全一致.
```c
SOCKET servSock;
struct sockaddr_in servAddr;
char* servPort="9190";
/* 创建服务器端套接字 */
servSock=socket(PF_INET,SOCK_STREAM,0);
/* 地址信息初始化 */
memset(&servAddr,0,sizeof(servAddr));
servAddr.sin_family=AF_INET;
servAddr.sin_addr.s_addr=htonl(INADDR_ANY);
servAddr.sin_port=htons(atoi(serv_port));
/* 分配地址信息 */
bind(servSock,(struct sockaddr*)&servAddr,sizeof(servAddr));
//... ...
```
这与`Linux`平台基本一致,只不过修改了一些额变量名.
### `WSAStringToAddress & WSAAddressToString`
下面介绍`Winsock2`中独有的地址和字符串转换函数,它们的功能与`inet_ntoa()`和
`inet_addr`完全相同,但是优点在于支持多种协议,在`IPv4`和`IPv6`中均可使用.

当然这两个函数也有缺点,它们依赖于`Windows`平台,这会降低程序的操作系统兼容性.

因此本书只会不会使用它们,介绍的目的在于让各位了解更多函数.
#### `WSAStringToAddress()`
```c
#include<winsock2.h>

// AddressString:含有IP和端口号的字符串地址值
// AddressFamily:第一个参数中地址所属的地址族信息
// lpProtocolInfo:设置协议提供者(Provider),默认为NULL
// lpAddress:保存地址信息的结构体变量地址值
// lpAddressLength:第四个参数中传递的结构体长度所在的变量地址值
INT WSAStringToAddress(
    LPTSTR AddressString, INT AddressFamily, LPWSAPROTOCOL_INFO lpProtocolInfo,
    LPSOCKADDR lpAddress, LPINT lpAddressLength
);
    // 成功时返回0
    // 失败时返回SOCKET_ERROR
```
#### `WSAAddressToString()`
`WSAAddressToString`与`WSAStringToAddress`在功能上正好相反,
它将结构体中的地址信息转换为字符串形式.
```c
#include<winsock2.h>

// lpsaAddress:需要转换的地址信息结构体本变量地址值
// dwAddressLength:第一个参数中结构体的长度
// lpProtocolInfo:设置协议提供者(Provider),默认为NULL
// lpszAddressString:保存转换结果的字符串地址值
// lpdwAddressStringLength:第四个参数中存有地址信息的字符串长度
INT WSAAddressToString(
    LPSOCKADDR lpsaAddress, DWORD dwAddressLength,
    LPWSAPROTOCOL_INFO lpProtocolInfo, LPSTR lpszAddressString,
    LPDWORD lpdwAddressStringLength
);
    // 成功时返回0
    // 失败时返回SOCKET_ERROR
```
#### `conv_addr_win.c`
```c
/*
#undef用于取消之前定义的宏.
根据项目环境,VC++会自主声明这2个宏,
在之后调用的转换函数中,参数就将转换为unicode形式,给出错误的运行结果.
所以插入了这2句宏定义
*/
#undef UNICODE
#undef _UNICODE
#include<stdio.h>
#include<winsock2.h>

int main(int argc,char* argv[]){

    char* strAddr="203.211.218.102:9190";
    char strAddrBuf[50];
    SOCKADDR_IN servAddr;
    int size;

    WSADATA wsaData;
    WSAStartup(MAKEWORD(2,2),&wsaData);

    size=sizeof(servAddr);
    // 调用WSAStringToAddress函数转换成结构体
    WSAStringToAddress(
        strAddr,AF_INET,NULL,(SOCKADDR*)&servAddr,&size
    );

    size=sizeof(strAddrBuf);
    // 调用WSAAddressToString函数将结构体转换为字符串
    WSAAddressToString(
        (SOCKADDR*)&servAddr,sizeof(servAddr),NULL,strAddrBuf,&size
    );

    printf("Second conv result: %s \n",strAddrBuf);
    WSACleanup();
    return 0;
}
```
##### 运行结果
```txt
Second conv result: 203.211.218.102:9190
```
上述示例中声明了`SOCKADDR_IN`类型的变量,
读者不必感到疑惑,实际上二者完全相同,
只是为了简化变量定义添加了`typedef`声明.
```c
typedef struct sockaddr_in SOCKADDR_IN;
```
## 3.6 习题
(1) `IP`地址族`IPv4`和`IPv6`有何区别?在何种背景下诞生了`IPv6`?

(2) 通过`IPv4`网络`ID`,主机`ID`
及路由器的关系说明向公司局域网中的计算机传输数据的过程.

(3) 套接字地址分为`IP`地址和端口号.为什么需要`IP`地址和端口号?
或者说,通过`IP`可以区分哪些对象?通过端口号可以区分哪些对象?

(4) 请说明`IP`地址的分类方法,并据此说出下面这些`IP`地址的分类.

+ 214.121.212.102 ( )
+ 120.101.122.89 ( )
+ 129.78.102.211 ( )

(5) 计算机通过路由器或交换机连接到互联网.请说出路由器和交换机的作用.

(6) 什么是知名端口?其范围是多少?
知名端口中具有代表性的`HTTP`和`FTP`端口号是多少?

(7) 向套接字分配地址的`bind`函数原型如下:
```c
int bind(int sockfd,struct sockaddr* myaddr,socklen_t addrlen);
```
而调用时则用
```c
bind(serv_sock,(struct sockaddr*)&serv_addr,sizeof(serv_addr));
```
此处`serv_addr`为`sockaddr_in`结构体变量.

与函数原型不同,传入的是`sockaddr_in`结构体变量,请说明原因.

(8) 请解释大端序,小端序,网络字节序,并说明为何需要网络字节序.

(9) 大端序计算机希望把4字节整数型数据12传递到小端序计算机.
请说出数据传输过程中发生的字节序变换过程.

(10) 怎样表示回送地址?其含义是多少?如果向回送地址传输数据将发生什么情况?

### 习题答案

(1) `IP`地址族`IPv4`和`IPv6`有何区别?在何种背景下诞生了`IPv6`?

区别是地址的长度不同,在`IPv4`地址趋于耗尽的情况下产生了`IPv6`.

(2) 通过`IPv4`网络`ID`,主机`ID`
及路由器的关系说明向公司局域网中的计算机传输数据的过程.

通过目标`IP`的网络`ID`找打目标网路的路由器,
路由器根据主机`ID`将数据包转发到局域网内的特定主机,
数据包经过多个路由器接力传输,每个路由器根据特定路由表决定下一跳.

(3) 套接字地址分为`IP`地址和端口号.为什么需要`IP`地址和端口号?
或者说,通过`IP`可以区分哪些对象?通过端口号可以区分哪些对象?

`IP`地址可以找到具体的机器,端口号可以找到这个机器上正在运行的套接字,
通过`IP`地址可以区分不同的计算机,通过端口号可以区分编号不同的套接字.

(4) 请说明`IP`地址的分类方法,并据此说出下面这些`IP`地址的分类.

+ 214.121.212.102 (c类)
+ 120.101.122.89 (a类)
+ 129.78.102.211 (b类)

(5) 计算机通过路由器或交换机连接到互联网.请说出路由器和交换机的作用.

路由器:连接不同网络,基于`IP`地址进行路由选择,
交换机:在局域网内基于`MAC`地址转发数据帧.

(6) 什么是知名端口?其范围是多少?
知名端口中具有代表性的`HTTP`和`FTP`端口号是多少?

知名端口就是约定俗成的常见协议预留的端口号,它的范围是`[0,1023]`.
`HTTP`端口:`80`,
`FTP`端口:`21`.

(7) 向套接字分配地址的`bind`函数原型如下:
```c
int bind(int sockfd,struct sockaddr* myaddr,socklen_t addrlen);
```
而调用时则用
```c
bind(serv_sock,(struct sockaddr*)&serv_addr,sizeof(serv_addr));
```
此处`serv_addr`为`sockaddr_in`结构体变量.

与函数原型不同,传入的是`sockaddr_in`结构体变量,请说明原因.

直接使用`struct sockaddr`结构体,初始化地址信息非常麻烦,
为了简化这个过程,使用成员个数和内存的大小相同的`struct sockaddr_in`进行替代.
但是注意:

`struct sockaddr`是通用的地址结构体,用于支持多种协议族.

`struct sockaddr_in`是专门为`IPv4`设计的具体结构体,

提供了更直观的字段(如`sin_addr`,`sin_port`).
通过强制类型转换,可以在保证接口一致性的同时,提供类型安全的操作.

这种强制类型转换实际上就是模拟从子类`struct sockaddr_in`
向基类`struct sockaddr`转换的过程.

(8) 请解释大端序,小端序,网络字节序,并说明为何需要网络字节序.

大端序和小端序是根据数据在内存中的存储顺序决定的.

例如,一个多字节数据类型的高8位和低8位数据是存储在大地址,还是小地址.
由此可以分为大端序和小端序.

将高位字节数据存放在低地址的是大端序,
将低位字节数据存放在低地址的是小端序.

而在网络传输过程中需要统一数据传输的字节顺序,因此数据的存储顺序是非常重要的.
网络字节序是大端序.

个人的思考:为什么直接在网络中传输多字节结构体会被直接传输文本文件的方式取代?

多字节结构体因为成员变量类型的多样性
(成员可能是单字节数据及其序列,也可能是多字节数据及其序列),
在网络传输数据之前需要根据实际情况进行字节序的统一.
使用传输单字节字符文本文件的方式进行传输,由于是单字节字符序列,
就不会出现字节序的统一问题.
例如直接传输`UTF-8`编码的`JSON`文件.

(9) 大端序计算机希望把4字节整数型数据12传递到小端序计算机.
请说出数据传输过程中发生的字节序变换过程.

```txt
大端序计算机             网络字节序               小端序计算机
[00 00 00 0C]--htonl()-->[00 00 00 0C]--ntohl()-->[0C 00 00 00]
```

(10) 怎样表示回送地址?其含义是多少?如果向回送地址传输数据将发生什么情况?

回送地址指的是本机地址,回送地址`IPv4`是`127.0.0.1`,`IPv6`是`::1`.
向回送地址传输数据也就是向本机传输数据,只要规定好网络协议和端口号,
就能进行本机数据通信.
