# 第三章 地址族与数据序列
本章重点讲解给套接字分配`IP`地址和端口号.
## 3.1 分配给套接字的`IP`地址与端口号
`IP`是`Internet Protocol`(网络协议)的简写.
为了收发数据而`分配给计算机的值`.

`端口号`是为了区分程序中创建的套接字而`分配给套接字的序号`.
### 网络地址(`Internet Address`)
`IP`地址分为2类:
1. `IPv4`(`Internet Protocol version 4`) `4`字节地址族
2. `IPv6`(`Internet Protocol version 6`) `6`字节地址族

`IPv4`与`IPv6`的差别主要是`IP`地址所用的字节数.

`IPv6`是为了应对`IPv4`地址耗尽问题而提出的标准.

`IPv4`标准的4字节`IP`地址包含网络地址和主机(指的是计算机本身)地址,
且分为`A`,`B`,`C`,`D`,`E`等类型,`E`类地址一般不会被使用,先略去不讲.
### `IPv4`地址族
```txt
A类  [1字节|1字节|1字节|1字节]
      \_ _/ \_______ _______/
        V           V
     网络ID      主机ID

B类  [1字节|1字节|1字节|1字节]
      \____ ____/ \____ ____/
           V           V
        网络ID      主机ID

C类  [1字节|1字节|1字节|1字节]
      \_______ _______/ \_ _/
              V           V
           网络ID      主机ID

D类  [1字节|1字节|1字节|1字节]
      \__________ __________/
                 V
            多播IP地址
```
### 基于`IP`地址的数据传递过程
```txt
                                        +-----MID.COM 203.211.172-----------+
                                        |                                   |
                                        |         [103号计算机]             |
                                        |               ^                   |
        +向203.211.172.103传输的数据->[路由器]----+-----+---------+         |
        |                               |         V               V         |
        |                               |    [102号计算机]  [104号计算机]   |
        |                               +-----------------------------------+
[计算机]+                                                                    
        |                               +-----SEMI.COM 203.211.217----------+
        |                               |                                   |
        |                               |    [201号计算机]  [203号计算机]   |
        |                               |         ^               ^         |
        +向203.211.217.202传输的数据->[路由器]----+-----+---------+         |
                                        |               V                   |
                                        |         [202号计算机]             |
                                        +-----------------------------------+
```
某主机向`203.211.172.103`和`203.211.217.202`传输数据,
其中`203.211.172`和`203.211.217`为该网络的网络地址.

`向相应网络传输数据`实际上是向构成网络的路由器(`Router`)或交换机(`Switch`)
传递数据,由接收数据的路由器根据数据中的主机地址向目标主机传递数据.

这里有一个隐含的数据存储的信息,不知道读者发现了没有:

例如`IP`地址`203.211.172.103`在内存中是如何存储的呢?
```txt
index: 0   1   2   3
value:[203|211|172|103]
```
是上面的这种存储方式吗?谜底我们后面会揭晓.
#### 路由器和交换机
构建网络的过程中需要一种物理设备完成外网和本网主机之间的连接.
完成连接并进行数据交换的便是路由器或交换机.

它们实际上是一种计算机,交换机比路由器功能要简单一些.
### 网络地址分类与主机地址边界
只需要通过`IP`地址第一个字节的数字就可以判断`IP`地址的类型,
进而可以判断网络地址所占的字节数,
因为`IP`地址在设计的时候就根据`IP`地址的边界区分了网络地址:

`A`类地址的首字节范围:`0`~`127`

翻译成8位二进制(1字节):`0000 0000`~`0111 1111`

规律是二进制以`0`为开头.

`B`类地址的首字节范围:`128`~`191`

翻译成8位二进制(1字节):`1000 0000`~`1011 1111`

规律是二进制以`10`为开头.

`C`类地址的首字节范围:`192`~`223`

翻译成8位二进制(1字节):`1100 0000`~`1101 1111`

规律是二进制以`110`为开头.
### 用于区分套接字的端口号
#### 数据分配过程
```txt
[PORT 1020 套接字]<---+                +---to PORT 1020
                      +-由操作系统分配-+
[PORT 2040 套接字]<---+                +---to PORT 2040
```
计算机中一般配有`NIC`(`Network Interface Card`,网络接口卡)数据传输设备.
通过`NIC`向计算机内部传输数据时会用到`IP`地址.

操作系统负责把传递到内部的数据适当分配给套接字,
这时需要使用端口号来区分不同的套接字.

通过`NIC`接收的数据内存在`端口号`信息,操作系统需要参照端口号
把数据传输给端口号对应的套接字.

端口号是在同一操作系统内为区分不同套接字而设置的,
因此无法将1个端口号分配给不同的套接字.

端口号由16位二进制构成(2字节),可分配的端口号范围是`0`~`65535`.
但`0`~`1023`是知名端口(`Well-known PORT`),一般分配给特定应用程序,
所以应当分配此范围之外的值.

注意:尽量分配`1024`~`65535`的端口号使用.

另外,虽然端口号不能重复,但是`TCP`套接字和`UDP`套接字不会共用端口号.

例如:如果某`TCP`套接字使用了`9190`号端口,则其他`TCP`套接字就无法使用`9190`端口,
但是`UDP`套接字可以使用`9190`端口,并且和`TCP`的`9190`端口互不打扰.

总结:数据传输目标地址需要同时包含`IP`地址和端口号,只有这样,
数据才会被传输到最终的目的地(应用程序套接字).

这里我发现一个新问题:
给出一个端口号,我如何才能得知它使用`TCP`通信还是`UDP`通信呢?
首先从端口号信息是无法看出这一点的,
我只能分别使用`TCP`套接字和`UDP`套接字对服务器发起请求来尝试一下了.
## 3.2 地址信息的表示
`IP`地址和端口号在应用程序中是如何表示的呢?
### 表示`IPv4`地址的结构体
### `struct sockaddr_in{}`
```c
struct sockaddr_in{
    sa_family_t    sin_family ; //地址族(Address Family),简写为`AF_`
    uint16_t       sin_port   ; //16位(2字节)TCP/UDP端口号
    struct in_addr sin_addr   ; //32位(4字节)IPv4地址
    char           sin_zero[8]; //不使用
};
```
### `struct in_addr{}`
```c
struct in_addr{
    in_addr_t       s_addr    ; //32位(4字节)IPv4地址
};
```
上面的两个结构体中出现了一些类型:`sa_family_t`,`uint16_t`,`in_addr_t`.

这些类型可以参考`POSIX`
(`Portable Operating System Interface`,可移植操作系统接口).

`POSIX`是为`UNIX`系列操作系统设立的标准,它定义了一些其他的数据类型.
### `POSIX`中定义的数据类型
数据类型名称 |数据类型说明                      |声明的头文件
:------------|:---------------------------------|:-------------
`int8_t`     |signed 8-bit int                  |`sys/types.h`
`uint8_t`    |unsigned 8-bit int(unsigned char) |`sys/types.h`
`int16_t`    |signed 16-bit int                 |`sys/types.h`
`uint16_t`   |unsigned 16-bit int(unsigned char)|`sys/types.h`
`int32_t`    |signed 32-bit int                 |`sys/types.h`
`uint32_t`   |unsigned 32-bit int(unsigned char)|`sys/types.h`
`sa_family_t`|地址族(Address Family)            |`sys/socket.h`
`socklen_t`  |长度(length of struct)            |`sys/socket.h`
`in_addr_t`  |IP地址,声明为`uint32_t`           |`netinet/in.h`
`in_port_t`  |端口号,声明为`uint16_t`           |`netinet/in.h`
### `struct sockaddr_in{}`的成员分析
#### 成员`sin_family`
##### `地址族`
每种协议族适用的地址族不同.
`IPv4`使用4字节地址族,`IPv6`使用16字节地址族.

地址族(`Address Family`)|含义
:----------------------:|:---------------------------------
`AF_INET`               |`IPv4`网络协议中使用的地址族
`AF_INET6`              |`IPv6`网络协议中使用的地址族
`AF_LOCAL`              |本地通信中采用的`UNIX`协议的地址族
#### 成员`sin_port`
该成员保存16位二进制(2字节)端口号,重点在于它以网络字节序保存.(稍后会给出详细说明)
#### 成员`sin_addr`
该成员保存32位二进制(4字节)`IP`地址信息,且也以网络字节序保存.
```txt
struct in_addr <=> in_addr_t <=> uint32_t
```
可以简单理解为一个4字节的无符号整数类型.
#### 成员`sin_zero`
无特征含义.只是为了使结构体`sockaddr_in`的大小与`sockaddr`结构体保持一致.
必须填充为0,否则无法得到想要的结果.

从之前的服务器端代码中不难发现,我们在使用`struct sockaddr_in`的时候,
需要进行强制类型转换为`struct sockaddr`进行信息绑定.
```c
struct sockaddr_in serv_addr;
//....
if(bind(serv_sock,(struct sockaddr*)&serv_addr,sizeof(serv_addr))==-1){
    error_handling("bind() error!");
}
//....
```
下面给出`struct sockaddr{}`的定义.
#### `struct sockaddr{}`
```c
struct sockaddr{
    sa_family_t sin_family ; // 地址族(Address Family)
    char        sa_data[14]; // 地址信息
};
```
此结构体成员`sa_data`保存的地址信息需包含`IP`地址和端口号,剩余部分应填充`0`.
这也是`bind`函数要求的.

从这个结构体的成员来看,
直接填充`struct sockaddr{}`包含的地址信息是非常麻烦的,
继而就有了新的结构体`sockaddr_in`,来简化填充流程.
填充完毕之后,只需要强制类型转换为`sockaddr`型的结构体变量,
再传递给`bind`函数即可.
#### `struct sockaddr_in{}.sa_family=AF_INET`的真实含义
提出一个问题:

从`struct sockaddr_in{}`的成员信息来看,
这是一个专门为`IPv4`设计的,
但是我们却还需要给`sin_family`成员变量赋值`AF_INET`,来表示这是`IPv4`地址.
这是不是有点多余?

注意:`struct sockaddr{}`内部也有同名的`sa_family`成员.

原因很简单,因为`struct sockaddr`不是专门为`IPv4`设计的,
`struct sockaddr_in`仅仅是为了`IPv4`地址填充而创造的工具类.
## 3.3 网络字节序与地址变换
在不同的`CPU`中,4字节的整数型值(32位`IPv4`地址)在内存空间的保存方式可能是不同的.
有些`CPU`是顺序保存.

例如数字1的内存存储方式:
```txt
00000000 00000000 00000000 00000001
```
而另外一些`CPU`则以倒序保存.
```txt
00000001 00000000 00000000 00000000
```
如果不考虑上述问题,收发数据的时候就会发生问题.
这不仅仅局限在`IP`地址的传输上,甚至是数据包的传输.

因为保存顺序的不同意味着接收数据的解析顺序也不同.

注意这里的字节序问题仅仅是存在在传输多字节数据类型
(例如:`int16_t`,`int32_t`等)中,
在单字节数据类型(例如:`char`,`uint8_t`等)及其序列中,数据都是顺序存放的.
### 字节序(`Order`)与网络字节序
`CPU`向内存保存数据的方式有2种,这意味着`CPU`解析数据的方式也分为2种.
1. 大端序(`Big Endian`):高位字节存放在低位地址.

例如数字`0x12345678`(16进制表示的4字节数据)的内存存储方式:

起始地址是`0x20`.
```txt
address: 0x20 0x21 0x22 0x23
value  :[0x12|0x34|0x56|0x78]
```
2. 小端序(`Little Endian`):低位字节存放在高位地址.

例如数字`0x12345678`(16进制表示的4字节数据)的内存存储方式:

起始地址是`0x20`.
```txt
address: 0x20 0x21 0x22 0x23
value  :[0x78|0x56|0x34|0x12]
```
每种`CPU`的数据保存方式不一定相同.

代表`CPU`数据保存方式的字节序成为`主机字节序`(`Host Byte Order`).
#### 字节序问题
```txt
[大端序系统]--->[0x34]->[0x12]--->[小端序系统]
0x1234传输                        0x1234接收,但解析为0x3412!
```
正是因为上述问题的出现,在通过网络传输数据时约定字节序的统一方式尤为重要.

这种约定称为`网络字节序`(`Network Byte Order`),非常简单----统一为大端序.

即先把数据组(多字节数据类型及其序列)转化为大端序格式再进行网络传输.
### 字节序转换(`Endian Conversions`)
相信大家已经理解了为何要在填充`sockaddr_in`结构体前先将数据转换为为网络字节序,
接下来介绍帮助转换字节序的函数.
```c
//h:Host Byte Order
//n:Network Byte Order
//s:short(linux:2字节数据)
//l:long(linux:4字节数据)
unsigned short htons(unsigned short);
unsigned short ntohs(unsigned short);
unsigned long htonl(unsigned long);
unsigned long ntohl(unsigned long);
```
思考如下一个问题:

