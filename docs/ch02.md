# 第二章 套接字类型与协议设置
本章介绍套接字创建方法及不同套接字的特性.
## 2.1 套接字协议及其数据传输特性
`协议`一词给人的第一印象总是相当枯燥和困难,
但是各位要慢慢熟悉`协议`,因为它几乎是网络编程的全部内容.
### 关于协议(`Protocol`)
`协议`是为了完成数据交换而制定好的约定.

举个例子:

相隔很远的两人想展开对话,此时必须决定对话的方式,
即使用什么完成通信?
如果一方使用电话,那么另一方也只能使用电话,而不是书信.

在这里,电话就是两人对话的协议.
### 创建套接字
创建套接字的`socket()`已经在第一章中简要介绍过,
此处为了完全理解该函数,再次展开讨论.
#### `socket()`
```c
#include<sys/socket.h>

//domain:套接字中使用的协议族(Protocol Family)信息
//type:套接字数据传输类型信息
//protocol:计算机间数据通信中使用的协议信息
int socket(int domain,int type,int protocol);
    //成功时返回文件描述符
    //失败时返回-1
```
### 协议族(`Protocol Family`)
协议族是什么呢?
举一个例子:就像奶油意大利面和番茄意大利面都属于意大利面.

`socket()`函数的第一个参数就是需要传递套接字中使用的协议分类信息.
协议分类信息也称为`协议族`.

表2-1 头文件`sys/socket.h`中声明的协议族
名称|协议族
:----------:|:----:
`PF_INET`   |`IPv4`互联网协议族
`PF_INET6`  |`IPv6`互联网协议族
`PF_LOCAL`  |本地通信的`UNIX`协议族
`PF_PACKET` |底层套接字的协议族
`PF_IPX`    |`IPX Novell`协议族
### 套接字类型(`Type`)
套接字类型指的是套接字的数据传输方式,通过`socket()`的第二个参数传递.

在一个协议族中也许会存在多种数据传输方式.

下面介绍2种具有代表性的数据传输方式.
#### 套接字类型1:面向连接的套接字(`SOCK_STREAM`)
面向连接的套接字是怎么样传输数据的呢?

举一个例子:

两个工人通过一条传送带传递物品,只要传送带本身没有问题,就能保证数据不丢失,
而且传送带保证了数据的按序传递.
除此之外,还有一个重要的特点,传输的数据是一个整体,
发送方可以使用每次发送的是一个完整数据的一部分进行多次发送,
而且发送的这些数据没有数据边界(`Boundary`),
这里的数据边界可能代表的是对一个数据包整体的包装的那部分标识信息.

"100个糖果是分批传递的,但接收者凑齐100个之后才能装袋."

这里我发现了这种传输方式存在的的一个隐含的问题:

接收端怎么确定本次数据传输的数据已经全部发送完毕了呢?
我想了如下的两种方式用来解决:

1. 在传输的数据中使用类似`EOF`这样的标识符,接受到此符号之后,代表数据传输完毕
2. 在第一次传输数据的时候,就给出完整数据包的字节大小,
等到接收端接收到指定指定大小的数据之后,代表数据传输完毕.

"传输数据的计算机通过3次调用`write`函数传输了100字节的数据,
但接收数据的计算机可能仅仅通过一次`read`函数调用就接收了全部100个字节的数据."

总结一下,面向连接的套接字的传输方式的特点:

1. 传输过程中数据不会消失
2. 按顺序传输数据
3. 传输的数据不存在数据边界(`Boundary`)
4. (隐藏特性)需要用户自己制定接收方确保已完成接收全部数据的策略

另一个隐含的问题:接收方套接字的缓冲区溢出问题

收发数据的套接字内部有缓冲区`buffer`,可以看作是一个固定大小的字节数组.
但是这带来一个问题,发送方给接收方发送了很多数据,
这些数据都是缓存在接收方套接字的缓冲区内,
缓冲区数组的是存在存储上限的,
而此时接收方迟迟不调用`read`函数读取存放在缓冲区的数据,
以此来缩减缓冲区内的数据大小,
这直接导致缓冲区存储的数据量持续飙升,
终于缓冲区填满了,而这时候发送方又发来一些新数据,
那么这时候会发生什么呢?
1. 发送方套接字不会察觉到接收方套接字缓冲区已满,
继续发送新数据,导致新数据直接覆盖了缓冲区中未被读取的旧数据,
造成数据丢失.
2. 发送方套接字会察觉到接收方套接字缓冲区已满,过一段时间再查询一下,
直到接收方缓冲区有足够的写入空间,这时再写入新数据.

正确答案是2.(`TCP`的滑动窗口机制已经使用类似的处理思路完美解决了这个问题).

因此,不要轻易担心面向连接的套接字会发生数据丢失的问题.

还有一个需要强调的点:

套接字连接必须一一对应,
也就是说面向连接的套接字只能与另外一个同样是面向连接的套接字进行连接通信.
#### 套接字类型2:面向消息的套接字(`SOCK_DGRAM`)
如果向`socket`函数的第二个参数传递`SOCK_DGRAM`,则将创建面向消息的套接字.
那么面向消息的传输方式又是怎么样的呢?

面向消息的套接字可以比喻成高速移动的摩托车快递.
用摩托车发往同一目的地的2件包裹无需保证顺序,只要用最快的速度交给客户即可,
这种方式存在损坏或者丢失包裹的风险,而且包裹的大小也有一定的限制,
如果要传递大量包裹,需要分批次发送,另外,如果用2辆摩托车分别发送2件包裹,
则接受者也需要分2次进行接收.

这种特性就是"传输的数据具有数据边界".
存在数据边界意味着接收数据的次数应该和传输数据的次数相同(就像取快递一样).

1. 强调快速传输而不是顺序传输
2. 传输的数据可能丢失,也可能损毁
3. 传输的数据有数据边界
4. 限制每次传输的数据大小

我在思考一些问题:
使用面向消息的套接字进行数据传递的时候,会遇到一些问题:

1. 数据包收到了,但是他们的顺序是什么?
2. 有些数据包没收到,丢了也对业务没影响吗?
3. 接收端怎么处理收到的大量的繁杂的数据包?

最后,总结一下面向消息的套接字:
1. 不可靠的
2. 不按顺序传递的
3. 以数据的高速传输为主要目的

另外,面向消息的套接字不存在`连接`这个概念.
### 协议的最终选择
下面讲解`socket`函数的第三个参数,该参数是最终采用的协议.
`socket`函数的前2个参数往往已经给出了选择的协议的大致特点,

协议族|套接字类型|协议
:----:|:--------:|:--:
`PF_INET`|`SOCK_STREAM`|`IPPROTO_TCP`
`PF_INET`|`SOCK_DGRAM`|`IPPROTO_UDP`

在同一个协议族中存在多个数据传输方式相同的协议.

`PF_INET`协议族则是一个特殊的存在,它不像其他协议族那样,有更多的成员.

在`PF_INET`协议族中,每种数据传输方式只对应一种具体的协议.
面向连接的套接字对应`TCP`协议,面向消息的套接字对应`UDP`协议.

因此,如果选定`PF_INET`协议族,并选定了数据传输类型,
可以向`socket`函数的第三个参数传递`0`来省略协议信息.
### 面向连接的套接字:`TCP`套接字示例
不存在数据边界的真实含义:
发送方发送数据的写入次数,和接收方接收数据的读取次数不需要一致,
但是发送方发送的总数据的大小和接收方收到的总数据的大小是一致的.

为了验证这一点,给出如下的`TCP`客户端代码:
#### `tcp_client.c`
```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<unistd.h>
#include<arpa/inet.h>
#include<sys/socket.h>

void error_handling(char const* message);

int main(int argc,char* argv[]){

    if(argc!=3){
        printf("Usage:%s <IP> <port>\n",argv[0]);
        exit(1);
    }

    int sock;
    //创建TCP套接字
    //若前两个参数传递PF_INET,SOCK_STREAM,
    //则可以省略第三个参数IPPROTO_TCP
    sock=socket(PF_INET,SOCK_STREAM,0);
    if(sock==-1){
        error_handling("socket() error!");
    }

    struct sockaddr_in serv_addr;
    memset(&serv_addr,0,sizeof(serv_addr));
    serv_addr.sin_family=AF_INET;
    serv_addr.sin_addr.s_addr=inet_addr(argv[1]);
    serv_addr.sin_port=htons(atoi(argv[2]));

    if(connect(sock,(struct sockaddr*)&serv_addr,sizeof(serv_addr))==-1){
        error_handling("connect() error!");
    }

    char message[30];
    int str_len=0,idx=0,read_len=0;
    //while循环中反复调用read函数,每次读取1个字节
    //如果read返回0,则循环条件为假,跳出while循环
    while(read_len=read(sock,&message[idx++],1)){
        if(read_len==-1){
            error_handling("read() error!");
        }
        //执行该语句时,变量read_len始终为1,因为每次只读取1个字节
        //跳出while循环后,str_len中存有读取的总字节数
        str_len+=read_len;
    }

    printf("Message from server : %s \n",message);
    printf("Function read call count: %d \n",str_len);
    close(sock);
    return 0;
}

void error_handling(char const* message){
    fputs(message,stderr);
    fputc('\n',stderr);
    exit(1);
}
```
#### 运行结果
```txt
Message from server : Hello World! 
Function read call count: 13 
```
## 2.2 `Windows`平台下的实现及验证
`Windows`平台下的`socket`函数的输入参数与`Linux`平台相同,
无需多言.
只是函数的返回值类型不同,我们来看一下:
### `socket()`
```c
#include<winsock2.h>

SOCKET socket(int af,int type,int protocol);
    //成功时返回socket句柄
    //失败时返回INVALID_SOCKET
```
返回值类型为`SOCKET`结构体,该结构体用来保存套接字句柄值.

下面给出在`Windows`平台创建套接字的正确做法(涉及错误处理).
```c
SOCKET soc=socket(PF_INET,SOCK_STREAM,IPPROTO_TCP);
if(INVALID_SOCKET==soc){
    ErrorHandling("socket() error!");
}
```
### 基于`Windows`的`TCP`套接字示例
#### `tcp_client_win.c`
```c
#include<stdio.h>
#include<stdlib.h>
#include<winsock2.h>

void ErrorHandling(char* message);

int main(int argc,char* argv[]){

    if(argc!=3){
        printf("Usage : %s <IP> <port>\n",argv[0]);
        exit(1);
    }

    WSADATA wsaData;
    if(WSAStartup(MAKEWORD(2,2),&wsaData)!=0){
        ErrorHandling("WSAStartup() error!");
    }

    //创建TCP套接字
    SOCKET hSocket;
    hSocket=socket(PF_INET,SOCK_STREAM,0);
    if(hSocket==INVALID_SOCKET){
        ErrorHandling("socket() error");
    }

    SOCKADDR_IN servAddr;
    memset(&servAddr,0,sizeof(servAddr));
    servAddr.sin_family=AF_INET;
    servAddr.sin_addr.s_addr=inet_addr(argv[1]);
    servAddr.sin_port=htons(atoi(argv[2]));

    if(connect(hSocket,(SOCKADDR*)&servAddr,sizeof(servAddr))==SOCKET_ERROR){
        ErrorHandling("connect() error!");
    }

    char message[30];
    int strLen=0,idx=0,readLen=0;
    //while循环中调用recv函数读取数据,每次1字节
    while(readLen=recv(hSocket,&message[idx++],1,0)){
        if(readLen==-1){
            ErrorHandling("read() error!");
        }
        //每次读取1字节,因此strLen每次加1,这与recv函数调用次数相同
        strLen+=readLen;
    }

    printf("Message from server: %s \n",message);
    printf("Function read call count: %d \n",strlen);

    closesocket(hSocket);
    WSACleanup();
    return 0;
}

void ErrorHandling(char* message){
    fputs(message,stderr);
    fputc('\n',stderr);
    exit(1);
}
```
#### 运行结果
```txt
```
## 2.3 习题
(1) 什么是协议?在收发数据中定义协议有何意义?

(2) 面向连接的TCP套接字传输特性有3点,请分别说明.

(3) 下列哪些是面向消息的套接字的特性?

    a. 传输数据可能丢失

    b. 没有数据边界(`Boundary`)

    c. 以快速传递为目标

    d. 不限制每次传递数据的大小

    e. 与面向连接的套机字不同,不存在连接的概念

(4) 下列数据适合用哪类套接字传输?并给出原因.

    a. 演唱会现场直播的多媒体数据()

    b. 某人压缩过的文本文件()

    c. 网上银行用户与银行之间的数据传递()

(5) 何种类型的套接字不存在数据边界?这类套接字接收数据时需要注意什么?

(6) `tcp_server.c`和`tcp_client.c`中需多次调用`read`函数读取服务器端,
调用1次`write`函数传递的字符串.
更改程序,使服务器端多次调用(次数自拟)`write`函数传输数据,
客户端调用1次`read`函数进行读取.
为达到这一目的,客户端延迟调用`read`函数,因为客户端要等待服务器端传输所有数据.
`Windows`和`Linux`都通过下列代码延迟`read`或`recv`函数的调用.
```c
for(i=0;i<3000;i++){
    printf("Wait time %d \n",i);
}
```
让`CPU`执行多余任务以延迟代码运行的方式成为`Busy Waiting`.
使用得当即可推迟函数调用.
### 解答
(1) 协议是计算机通信前制定的数据交换规则.

(2) 面向连接的套接字的传输特性

1. 可靠的
2. 传输的数据是有顺序的
3. 传输的数据是没有数据边界的

(3) a.c.e.

(4)

a. 面向消息的套接字

现场直播即便是包丢失也不会造成太大影响,最重要的是快速传递

b. 面向连接的套接字

涉及文件传输,最好选择传输可靠的面向连接的套接字.

c. 面向连接的套接字

涉及交易安全,最好选择传输可靠的面向连接的套接字.

(5)

面向连接的套接字不存在数据边界.

这类套接字在传输数据的时候,
需要注意接收方如何得知已经全部接收完毕发送方发送的全部数据,
需要提前约定好数据传输完毕的标志行为.

(6)

详见`ch02-tcp_server_busy_waiting`/`ch02-tcp_server_busy_waiting_win`/
`ch02-tcp_client_busy_waiting`/`ch02-tcp_client_busy_waiting_win`文件夹.
