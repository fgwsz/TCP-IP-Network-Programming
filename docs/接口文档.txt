//创建一个套接字
//  注意:套接字也是一个文件
//所属的头文件:
//  #include<sys/socket.h>
//input@domain:协议族(protocol family)
//  可以使用的协议族的值:
//      PF_INET     IPv4互联网协议族
//      PF_INET6    IPv6互联网协议族
//      PF_LOCAL    本地通信的UNIX协议族
//      PF_PACKET   底层套接字的协议族
//      PF_IPX      IPX Novell协议族
//input@type:类型
//  在协议族为PF_INET时可以使用的套接字类型的值:
//      SOCK_STREAM 面向连接的数据传输方式
//      SOCK_DGRAM  面向消息的数据传输方式
//input@protocol:协议
//  如果设置为0,表示指定的协议族中满足套接字类型要求的第一个协议
//  在协议族为PF_INET且套接字类型为SOCK_STREAM时可用的唯一一个协议值:
//      IPPROTO_TCP TCP协议
//  在协议族为PF_INET且套接字类型为SOCK_DGRAM时可用的唯一一个协议值:
//      IPPROTO_UDP UDP协议
//output:
//  成功时返回文件描述符
//  失败时返回-1
int socket(int domain,int type,int protocol);

//给套接字分配IP地址和端口号
//所属的头文件:
//  #include<sys/socket.h>
//input@sockfd:套接字的文件描述符
//input@myaddr:IP地址(包含端口号信息)
//input@addrlen:地址的长度
//output:
//  成功时返回0
//  失败时返回-1
int bind(int sockfd,struct sockaddr* myaddr,socklen_t addrlen);

//将套接字转为可接收连接请求状态
//所属的头文件:
//  #include<sys/socket.h>
//input@sockfd:套接字的文件描述符
//input@backlog:
//output:
//  成功时返回0
//  失败时返回-1
int listen(int sockfd,int backlog);

//通过套接字接受其他套接字的连接请求
//所属的头文件:
//  #include<sys/socket.h>
//input@sockfd:套接字的文件描述符
//input@addr:
//input@addrlen:
//output:
//  成功时返回发送连接请求的套接字的文件描述符
//  失败时返回-1
int accept(int sockfd,struct sockaddr* addr,socklen_t* addrlen);

//通过套接字向其他套接字发出连接请求
//所属的头文件:
//  #include<sys/socket.h>
//input@sockfd:套接字的文件描述符
//input@serv_addr:服务端的IP地址
//input@addrlen:地址的长度
//output:
//  成功时返回0
//  失败时返回-1
int connect(int sockfd,struct sockaddr* serv_addr,socklen_t* addrlen);

//linux中特殊的文件描述符
//0 标准输入:Standard Input
//1 标准输出:Standard Output
//2 标准错误:Standard Error

//打开一个文件
//所属的头文件:
//  #include<fcntl.h>
//input@path:文件路径
//input@flag:文件打开方式的标志参数
//  可用的标志参数值:
//      O_CREAT     必要时创建文件
//      O_TRUNC     删除全部数据
//      O_APPEND    维持现有数据,保存到其后面
//      O_RDONLY    只读打开
//      O_WRONLY    只写打开
//      O_RDWR      读写打开
//  可以通过位|方式来组合2种及以上的文件打开方式的标志参数值
//output:
//  成功时返回文件描述符
//  失败时返回-1
int open(char const* path,int flag);

//关闭一个文件
//所属的头文件:
//  #include<unistd.h>
//input@fd:要关闭的文件的文件描述符
//output:
//  成功时返回0
//  失败时返回-1
int close(int fd);

//有符号的整数类型
//所属的头文件:
//  #include<sys/types.h>
ssize_t

//向文件写入数据
//  将buf[0~nbytes-1]中的数据写入到文件描述符为fd的文件中
//  可以向套接字写入数据,因为套接字也是一个文件
//所属的头文件:
//  #include<unistd.h>
//input@fd:要写入数据的文件的文件描述符
//input@buf:存放有要被写入到文件里边的数据的缓冲区(buffer)的首地址
//input@nbytes:要写入的字节数
//output:
//  成功时返回已写入的字节数
//  失败时返回-1
ssize_t write(int fd,void const* buf,size_t nbytes);

//从文件中读取数据
//  可以向套接字写入数据,因为套接字也是一个文件
//所属的头文件:
//  #include<unistd.h>
//input@fd:要读取数据的文件的文件描述符
//input@buf:接收已经读取的数据的缓冲区(buffer)的首地址
//input@nbytes:要读取的字节数
//output:
//  成功时返回已读取的字节数(没有遇到表示文件结尾的特殊字符EOF)
//  在读取数据时如果遇到表示文件结尾的特殊字符EOF就返回0
//  失败时返回-1
ssize_t read(int fd,void const* buf,size_t nbytes);

//套接字地址结构体
//所属的头文件:
//  #include<netinet/in.h>
//作用:
//  简化IP地址构建方式,用于强制类型转换为struct sockaddr
struct sockadd_in{
    sa_family_t     sin_family;  //地址族(Address Family)
        //可以使用到地址族的值:
        //  AF_INET  IPv4网络协议中使用的地址族
        //  AF_INET6 IPv6网络协议中使用的地址族
        //  AF_LOCAL 本地通信中采用的UNIX协议的地址族
    uint16_t        sin_port;    //16位TCP/UDP端口号(网络字节序),占用2字节
    struct in_addr  sin_addr;    //32位IP地址(网络字节序),占用4字节
    char            sin_zero[8]; //用于内存对齐的占位内存空间,占用8字节
        //为使结构体sockaddr_in的大小与sockaddr结构体保持一致而插入的成员
        //必须填充为0,否则无法得到想要的结果
    //以上3项占用正好是14字节,对应struct sockaddr中的sa_data[14]这一项
};
struct in_addr{
    In_addr_t       s_addr;      //32位IPv4地址(网路字节序)
};
struct sockaddr{
    sa_family_t     sin_family;  //地址族(Address Family)
    char            sa_data[14]; //地址信息
};

POSIX中定义的一些数据类型
数据类型名称    |   数据类型说明                    |声明的头文件
int8_t          |signed 8-bit int                   |sys/types.h
uint8_t         |unsigned 8-bit int(unsigned char)  |sys/types.h
int16_t         |signed 16-bit int                  |sys/types.h
uint16_t        |unsigned 16-bit int(unsigned short)|sys/types.h
int32_t         |signed 32-bit int                  |sys/types.h
uint32_t        |unsigned 32-bit int(unsigned long) |sys/types.h

sa_family_t     |地址族(address family)             |sys/socket.h
socklen_t       |长度(length of struct)             |sys/socket.h

in_addr_t       |IP地址,声明为uint32_t              |netinet/in.h
in_port_t       |端口号,声明为uint16_t              |netinet/in.h

//字节序转换(Endian Coversions)
//所属的头文件:
//  #include<arpa/inet.h>
//缩写含义:
//  h代表主机(host)字节序
//  n代表网络(network)字节序
//  s代表unsigned short(linux中 uint16_t)占2字节
//  l代表unsigned long(linux中 uint32_t)占4字节
unsigned short htons(unsigned short);//把short数据从主机字节序转化为网络字节序
unsigned short ntohs(unsigned short);//把short数据从网络字节序转化为主机字节序
unsigned long htonl(unsigned long);//把long数据从主机字节序转化为网络字节序
unsigned long ntohl(unsigned long);//把long数据从网络字节序转化为主机字节序

//printf打印整数类型使用十六进制方式显示
#
    这个符号是一个格式化标志
    它改变默认的输出格式
    当它与十六进制格式x结合使用时,表示在输出的十六进制数前加上前缀0x
    以明确指示这是一个十六进制表示
    这通常用于指明数值是以十六进制形式展示的
    尤其是在处理指针或特定的十六进制数据时
x
    代表十六进制输出格式
    当使用x时,printf会将整数值转换为小写的十六进制数进行输出
    其中数字0到9保持不变,而字母a到f表示十六进制中的10到15

#x  适用于unsigned char/unsigned short/unsigned int
#lx 适用于unsigned long

//将字符串信息转换为网络字节序的整数型
//所属的头文件:
//  #include<arpa/inet.h>
//input@string:
//output:
//  成功时返回32位大端序整数型值
//  失败时返回INADDR_NONE
in_addr_t inet_addr(char const* string);
